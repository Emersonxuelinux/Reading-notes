##手机卫士75期笔记##

### 目录
- [手机卫士75期笔记](#phone-manager)
- [Day01](#day01)
    - [svn使用](#svn)
    - [splash界面作用](#splash界面作用)
    - [代码包结构划分方式](#代码包结构划分方式)
    - [spalsh界面搭建(重点)](#spalsh界面搭建(重点))
    - [获取版本号(重点)](#获取版本号(重点))
    - [连接服务器](#连接服务器)
    - [数据封装形式(重点)](#数据封装形式(重点))
    - [解析json数据(重点)](#解析json数据(重点))
    - [弹出对话框](#弹出对话框)
    - [对话框细节的处理](#对话框细节的处理)
    - [下载操作(重点)](#下载操作(重点))
    - [安装新的apk(重点)](#安装新的apk(重点))
    - [异常处理](#异常处理)
    - [两种上下文的区别](#两种上下文的区别)
    - [打包签名(重点)](#打包签名(重点))
- [Day02](#Day02)
	- [Gridview使用](#Gridview使用)
	- [Textview滚动效果](#Textview滚动效果)
	- [设置中心界面](#设置中心界面)
	- [自定义组合控件](#自定义组合控件)
	- [屏蔽自动更新](#屏蔽自动更新)

##Day10##

#系统程序和用户程序拆分#

	1.将集合拆分,分别保存
			@Override
			public void doinBack() {
				list = AppEngine.getAppInfos(getApplicationContext());
				userappinfo = new ArrayList<AppInfo>();
				systemappinfo = new ArrayList<AppInfo>();
				for (AppInfo appinfo : list) {
					//将数据分别存放到用户程序集合和系统程序集合中
					if (appinfo.isUser()) {
						userappinfo.add(appinfo);
					}else{
						systemappinfo.add(appinfo);
					}
				}
			}
	2.修改adapter的getcount返回值
			@Override
			public int getCount() {
				// TODO Auto-generated method stub
				//list.size() = userappinfo.size()+systemappinfo.size()
				return userappinfo.size()+systemappinfo.size()+2;
			}
	3.在getview中增加条目,并获取数据

		增加条目
			if (position == 0) {
				//添加用户程序(...个)textview
				TextView textView = new TextView(getApplicationContext());
				textView.setBackgroundColor(Color.GRAY);
				textView.setTextColor(Color.WHITE);
				textView.setText("用户程序("+userappinfo.size()+")");
				return textView;
			}else if(position == userappinfo.size()+1){
				//添加系统程序(....个)textview
				TextView textView = new TextView(getApplicationContext());
				textView.setBackgroundColor(Color.GRAY);
				textView.setTextColor(Color.WHITE);
				textView.setText("系统程序("+systemappinfo.size()+")");
				return textView;
			}
		获取数据
			//1.获取应用程序的信息
			AppInfo appInfo;
			//数据就要从userappinfo和systemappinfo中获取
			if (position <= userappinfo.size()) {
				//用户程序
				appInfo = userappinfo.get(position-1);
			}else{
				//系统程序
				appInfo = systemappinfo.get(position - userappinfo.size() - 2);
			}
			
		判断缓存复用
			if (convertView != null && convertView instanceof RelativeLayout) {
				view = convertView;
				viewHolder = (ViewHolder) view.getTag();
			}else{

#浮动显示程序个数#

	/**
	 * listview滑动监听事件
	 */
	private void listviewOnscroll() {
		lv_softmanager_application.setOnScrollListener(new OnScrollListener() {
			//滑动状态改变的时候调用
			@Override
			public void onScrollStateChanged(AbsListView view, int scrollState) {
				// TODO Auto-generated method stub
				
			}
			//滑动的时候调用
			//view : listview
			//firstVisibleItem : 界面第一个显示条目
			//visibleItemCount : 显示条目总个数
			//totalItemCount : 条目的总个数
			@Override
			public void onScroll(AbsListView view, int firstVisibleItem,
					int visibleItemCount, int totalItemCount) {
				//为null的原因:listview在初始化的时候就会调用onScroll方法
				if (userappinfo != null && systemappinfo != null) {
					if (firstVisibleItem >= userappinfo.size()+1) {
						tv_softmanager_userorsystem.setText("系统程序("+systemappinfo.size()+")");	
					}else{
						tv_softmanager_userorsystem.setText("用户程序("+userappinfo.size()+")");	
					}
				}
			}
		});
	}

#popuwindow操作#  (重点)

	/**
	 * 条目点击事件
	 */
	private void listviewItemClick() {
		lv_softmanager_application.setOnItemClickListener(new OnItemClickListener() {

			//view : 条目的view对象
			@Override
			public void onItemClick(AdapterView<?> parent, View view,
					int position, long id) {
				//弹出气泡
				//1.屏蔽用户程序和系统程序(...个)弹出气泡
				if (position == 0 || position == userappinfo.size()+1) {
					return;
				}
				//2.获取条目所对应的应用程序的信息
				//数据就要从userappinfo和systemappinfo中获取
				if (position <= userappinfo.size()) {
					//用户程序
					appInfo = userappinfo.get(position-1);
				}else{
					//系统程序
					appInfo = systemappinfo.get(position - userappinfo.size() - 2);
				}
				//5.弹出新的气泡之前,删除旧 的气泡
				hidePopuwindow();
				//3.弹出气泡
				/*TextView contentView = new TextView(getApplicationContext());
				contentView.setText("我是popuwindow的textview控件");
				contentView.setBackgroundColor(Color.RED);*/
				View contentView = View.inflate(getApplicationContext(), R.layout.popu_window, null);
				//contentView : 显示view对象
				//width,height : view宽高
				popupWindow = new PopupWindow(contentView, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
				//4.获取条目的位置,让气泡显示在相应的条目
				int[] location = new int[2];//保存x和y坐标的数组
				view.getLocationInWindow(location);//获取条目x和y的坐标,同时保存到int[]
				//获取x和y的坐标
				int x = location[0];
				int y = location[1];
				//parent : 要挂载在那个控件上
				//gravity,x,y : 控制popuwindow显示的位置
				popupWindow.showAtLocation(parent, Gravity.LEFT | Gravity.TOP, x+50, y);
			}

		});
	}

	隐藏气泡
		/**
		 * 隐藏气泡
		 */
		private void hidePopuwindow() {
			if (popupWindow != null) {
				popupWindow.dismiss();//隐藏气泡
				popupWindow = null;
			}
		}

#popuwindow动画# (重点)

	动画要想执行,执行的控件必须有背景,动画都是基于背景来进行一些计算,没有背景动画是无法执行,popuwindow默认是没有设置背景

	//6.设置动画
				//缩放动画
				//前四个 :　控制控件由没有变到有   动画 0:没有    1:整个控件
				//后四个:控制控件是按照自身还是父控件进行变化
				//RELATIVE_TO_SELF : 以自身变化
				//RELATIVE_TO_PARENT : 以父控件变化
				ScaleAnimation scaleAnimation = new ScaleAnimation(0, 1, 0, 1, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 0.5f);
				scaleAnimation.setDuration(500);
				
				//渐变动画
				AlphaAnimation alphaAnimation = new AlphaAnimation(0.4f, 1.0f);//由半透明变成不透明
				alphaAnimation.setDuration(500);
				
				//组合动画
				//shareInterpolator : 是否使用相同的动画插补器  true:共享    false:各自使用各自的
				AnimationSet animationSet = new AnimationSet(true);
				//添加动画
				animationSet.addAnimation(scaleAnimation);
				animationSet.addAnimation(alphaAnimation);
				//执行动画
				contentView.startAnimation(animationSet);
	给popuwindow设置背景
		popupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));

#设置控件点击事件#

	1.初始化控件
				//初始化控件
				LinearLayout ll_popuwindow_uninstall = (LinearLayout) contentView.findViewById(R.id.ll_popuwindow_uninstall);
				LinearLayout ll_popuwindow_start = (LinearLayout) contentView.findViewById(R.id.ll_popuwindow_start);
				LinearLayout ll_popuwindow_share = (LinearLayout) contentView.findViewById(R.id.ll_popuwindow_share);
				LinearLayout ll_popuwindow_detail = (LinearLayout) contentView.findViewById(R.id.ll_popuwindow_detail);
	2.activity实现点击事件接口,并实现相应的点击事件方法,同时设置控件点击事件
			public class SoftMangaerActivity extends Activity implements OnClickListener {
		
				//给控件设置点击事件
				ll_popuwindow_uninstall.setOnClickListener(SoftMangaerActivity.this);
				ll_popuwindow_start.setOnClickListener(SoftMangaerActivity.this);
				ll_popuwindow_share.setOnClickListener(SoftMangaerActivity.this);
				ll_popuwindow_detail.setOnClickListener(SoftMangaerActivity.this);
			
			@Override
			public void onClick(View v) {
				//判断点击是按个按钮
				//getId() : 获取点击按钮的id
				switch (v.getId()) {
				case R.id.ll_popuwindow_uninstall:
					System.out.println("卸载");
					break;
				case R.id.ll_popuwindow_start:
					System.out.println("启动");
					break;
				case R.id.ll_popuwindow_share:
					System.out.println("分享");
					break;
				case R.id.ll_popuwindow_detail:
					System.out.println("详情");
					break;
				}
			}

#卸载#

		/**
		 * 卸载
		 */
		private void uninstall() {
			/**
			 * <intent-filter>
	                <action android:name="android.intent.action.VIEW" />
	                <action android:name="android.intent.action.DELETE" />
	                <category android:name="android.intent.category.DEFAULT" />
	                <data android:scheme="package" />
	            </intent-filter>
			 */
			//判断是否是系统程序
			if (appInfo.isUser()) {
				//判断是否是我们自己的应用,是不能卸载
				if (!appInfo.getPackagName().equals(getPackageName())) {
					Intent intent = new Intent();
					intent.setAction("android.intent.action.DELETE");
					intent.addCategory("android.intent.category.DEFAULT");
					intent.setData(Uri.parse("package:"+appInfo.getPackagName()));//tel:110
					startActivityForResult(intent,0);
				}else{
					Toast.makeText(getApplicationContext(), "文明社会,杜绝自杀", 0).show();
				}
			}else{
				Toast.makeText(getApplicationContext(), "要想卸载系统程序,请root先", 0).show();
			}
		}
		@Override
		protected void onActivityResult(int requestCode, int resultCode, Intent data) {
			super.onActivityResult(requestCode, resultCode, data);
			fillData();
		}

#启动#

	/**
	 * 启动
	 */
	private void start() {
		PackageManager pm = getPackageManager();
		//获取应用程序的启动意图
		Intent intent = pm.getLaunchIntentForPackage(appInfo.getPackagName());
		if (intent!=null) {
			startActivity(intent);
		}else{
			Toast.makeText(getApplicationContext(), "系统核心程序,无法启动", 0).show();
		}
	}

#详情#
	
	通过系统log查看跳转操作
	
	/**
	 *详情
	 */
	private void detail() {
		/**
		 *  Intent 
			{ 
			act=android.settings.APPLICATION_DETAILS_SETTINGS    action
			dat=package:com.example.android.apis   data
			cmp=com.android.settings/.applications.InstalledAppDetails 
			} from pid 228
		 */
		Intent intent = new Intent();
		intent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS");
		intent.setData(Uri.parse("package:"+appInfo.getPackagName()));
		startActivity(intent);
	}

#分享# (重点)

	1.分享
		/**
		 *  Intent 
			{ 
				act=android.intent.action.SEND 
				typ=text/plain 
				flg=0x3000000 
				cmp=com.android.mms/.ui.ComposeMessageActivity (has extras)   intent中包含信息
			} from pid 228
		 */
		Intent intent = new Intent();
		intent.setAction("android.intent.action.SEND");
		intent.setType("text/plain");
		intent.putExtra(Intent.EXTRA_TEXT, "发现一个很牛x软件"+appInfo.getName()+",下载地址:www.baidu.com,自己去搜");
		startActivity(intent);
	2.如果是应用能够进行分享操作
		a.在activity中添加意图
			<!-- 表名应用程序能够接受分享信息 -->
            <intent-filter>
               <action android:name="android.intent.action.SEND" />
               <category android:name="android.intent.category.DEFAULT" />
               <data android:mimeType="text/plain" />
           </intent-filter>
		b.接受分享信息
			Intent intent = getIntent();
			String stringExtra = intent.getStringExtra(Intent.EXTRA_TEXT);
			if (!TextUtils.isEmpty(stringExtra)) {
				iv_share.setText(stringExtra);
			}

	shareSDK

#获取可用空间#

	1.apputil
		/**
		 * 获取SD卡可用空间
		 */
		public static long getAvailableSD(){
			 //获取SD卡路径
			 File path = Environment.getExternalStorageDirectory();
			 //硬盘的API操作
	         StatFs stat = new StatFs(path.getPath());
	         long blockSize = stat.getBlockSize();//获取每块的大小
	         long totalBlocks = stat.getBlockCount();//获取总块数
	         long availableBlocks = stat.getAvailableBlocks();//获取可用的块数
	         return availableBlocks*blockSize;
		}
		/**
		 *获取内存可用空间
		 * @return
		 */
		public static long getAvailableROM(){
			//获取内存路径
			File path = Environment.getDataDirectory();
			//硬盘的API操作
	        StatFs stat = new StatFs(path.getPath());
	        long blockSize = stat.getBlockSize();//获取每块的大小
	        long totalBlocks = stat.getBlockCount();//获取总块数
	        long availableBlocks = stat.getAvailableBlocks();//获取可用的块数
	        return availableBlocks*blockSize;
		}
	2.使用
		//获取可用内存,获取都是kb
		long availableSD = AppUtil.getAvailableSD();
		long availableROM = AppUtil.getAvailableROM();
		//数据转化
		String sdsize = Formatter.formatFileSize(getApplicationContext(), availableSD);
		String romsize = Formatter.formatFileSize(getApplicationContext(), availableROM);
		//设置显示
		tv_softmanager_sd.setText("SD卡可用:"+sdsize);
		tv_softmanager_rom.setText("内存可用:"+romsize);

#获取系统所有进程信息# (重点)

	/**
	 * 获取系统中所有进程信息
	 * @return
	 */
	public static List<TaskInfo> getTaskAllInfo(Context context){
		List<TaskInfo> list = new ArrayList<TaskInfo>();
		//1.进程的管理者
		ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
		PackageManager pm = context.getPackageManager();
		//2.获取所有正在运行的进程信息
		List<RunningAppProcessInfo> runningAppProcesses = activityManager.getRunningAppProcesses();
		//遍历集合
		for (RunningAppProcessInfo runningAppProcessInfo : runningAppProcesses) {
			TaskInfo taskInfo = new TaskInfo();
			//3.获取相应的信息
			//获取进程的名称,获取包名
			String packagName = runningAppProcessInfo.processName;
			taskInfo.setPackageName(packagName);
			//获取进程所占的内存空间,int[] pids : 输入几个进程的pid,就会返回几个进程所占的空间
			MemoryInfo[] memoryInfo = activityManager.getProcessMemoryInfo(new int[]{runningAppProcessInfo.pid});
			int totalPss = memoryInfo[0].getTotalPss();
			long ramSize = totalPss*1024;
			taskInfo.setRamSize(ramSize);
			try {
				//获取application信息
				//packageName : 包名     flags:指定信息标签
				ApplicationInfo applicationInfo = pm.getApplicationInfo(packagName, 0);
				//获取图标
				Drawable icon = applicationInfo.loadIcon(pm);
				taskInfo.setIcon(icon);
				//获取名称
				String name = applicationInfo.loadLabel(pm).toString();
				taskInfo.setName(name);
				//获取程序的所有标签信息,是否是系统程序是以标签的形式展示
				int flags = applicationInfo.flags;
				boolean isUser;
				//判断是否是用户程序
				if ((applicationInfo.FLAG_SYSTEM & flags) == applicationInfo.FLAG_SYSTEM) {
					//系统程序
					isUser = false;
				}else{
					//用户程序
					isUser = true;
				}
				//保存信息
				taskInfo.setUser(isUser);
			} catch (NameNotFoundException e) {
				e.printStackTrace();
			}
			//taskinfo添加到集合
			list.add(taskInfo);
		}
		return list;
	}

#进程管理界面# (重点:思路)

	按照软件管理思路一步步复制

#checkboxBug解决#  (重点)

	问题:checkbox的状态会跟着控件一起复用,
	解决:所以将状态保存到bean类中,根据bean中保存的状态在getview中进行动态设置
	1.将状态设置到bean类中
		//checkbox是否被选中
		private boolean isChecked = false;
	2.在getview中进行动态判断设置
			//因为checkbox的状态会跟着一起复用,所以一般要动态修改的控件的状态,不会跟着去复用,而是将状态保存到bean对象,在每次复用使用控件的时候
			//根据每个条目对应的bean对象保存的状态,来设置控件显示的相应的状态
			if (taskinfo.isChecked()) {
				viewHolder.cb_itemtaskmanager_ischecked.setChecked(true);
			}else{
				viewHolder.cb_itemtaskmanager_ischecked.setChecked(false);
			}
	3.屏蔽checkbox的获取焦点和点击事件
		<CheckBox 
		    android:id="@+id/cb_itemtaskmanager_ischecked"
		    android:layout_width="wrap_content"
		    android:layout_height="wrap_content"
		    android:layout_alignParentRight="true"
		    android:layout_centerVertical="true"
		    android:layout_marginRight="15dp"
		    android:focusable="false"
		    android:clickable="false"
		    />
	4.屏蔽之后,发现点击条目无法更改checkbox的状态,所以设置条目点击事件进行更改
		/**
		 * listview条目点击事件
		 */
		private void listviewItemClick() {
			lv_taskmanager_processes.setOnItemClickListener(new OnItemClickListener() {
				//view : 条目的view对象
				@Override
				public void onItemClick(AdapterView<?> parent, View view,
						int position, long id) {
					//动态改变checkbox状态
					//1.屏蔽用户程序和系统程序(...个)弹出气泡
					if (position == 0 || position == userappinfo.size()+1) {
						return;
					}
					//2.获取条目所对应的应用程序的信息
					//数据就要从userappinfo和systemappinfo中获取
					if (position <= userappinfo.size()) {
						//用户程序
						taskInfo = userappinfo.get(position-1);
					}else{
						//系统程序
						taskInfo = systemappinfo.get(position - userappinfo.size() - 2);
					}
					//3.根据之前保存的checkbox的状态设置点击之后的状态,原先选中,点击之后不选中
					if (taskInfo.isChecked()) {
						taskInfo.setChecked(false);
					}else{
						taskInfo.setChecked(true);
					}
					//4.更新界面
					//myadapter.notifyDataSetChanged();
					//只更新点击的条目
					ViewHolder viewHolder = (ViewHolder) view.getTag();
					viewHolder.cb_itemtaskmanager_ischecked.setChecked(taskInfo.isChecked());
				}
			});
		}
	5.单独更新单个条目
		因为控件是保存在ViewHolder控件容器中,而容器又是在listview条目展示的时候通过view.settag和view对象进行绑定了,那我们就可以在条目点击事件进行使用处理,因为在条目点击事件中有view参数,这个参数代表就是点击条目的view对象,通过view.gettag获取到和view对象绑定的容器,从容器中获取控件,设置控件的状态了

#全选和取消#

		/**
		 * 全选
		 * @param v
		 */
		public void all(View v){
			//用户进程
			for (int i = 0; i < userappinfo.size(); i++) {
				userappinfo.get(i).setChecked(true);
			}
			//系统进程
			for (int i = 0; i < systemappinfo.size(); i++) {
				systemappinfo.get(i).setChecked(true);
			}
			//更新界面
			myadapter.notifyDataSetChanged();
		}
		/**
		 * 取消
		 * @param v
		 */
		public void cancel(View v){
			//用户进程
			for (int i = 0; i < userappinfo.size(); i++) {
				userappinfo.get(i).setChecked(false);
			}
			//系统进程
			for (int i = 0; i < systemappinfo.size(); i++) {
				systemappinfo.get(i).setChecked(false);
			}
			//更新界面
			myadapter.notifyDataSetChanged();
		}

#清理进程# (重点:五个进程)

	android进程
		1.前台进程  正在操作的进程,正在运行进程,不可杀死
		2.可见进程  没有焦点,但是可见的进程
		3.服务进程  包含服务的进程,当内存不足的时候,会被杀掉,当内存充足的时候,重新服务进程
		4.后台进程  点击home键,最小化
		5.空进程    退出,为了下次能够快速启动

	后台进程和空进程是可以通过代码杀死

	/**
	 * 清理
	 * @param v
	 */
	public void clear(View v){
		//1.获取进程的管理者
		ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
		//保存杀死进程信息的集合
		List<TaskInfo> deleteTaskInfos = new ArrayList<TaskInfo>();
		
		for (int i = 0; i < userappinfo.size(); i++) {
			if (userappinfo.get(i).isChecked()) {
				//杀死进程
				//packageName : 进程的包名
				//杀死后台进程
				am.killBackgroundProcesses(userappinfo.get(i).getPackageName());
				deleteTaskInfos.add(userappinfo.get(i));//将杀死的进程信息保存的集合中
			}
		}
		//系统进程
		for (int i = 0; i < systemappinfo.size(); i++) {
			if (systemappinfo.get(i).isChecked()) {
				//杀死进程
				//packageName : 进程的包名
				//杀死后台进程
				am.killBackgroundProcesses(systemappinfo.get(i).getPackageName());
				deleteTaskInfos.add(systemappinfo.get(i));//将杀死的进程信息保存的集合中
			}
		}
		//遍历deleteTaskInfos,分别从userappinfo和systemappinfo中删除deleteTaskInfos中的数据
		for (TaskInfo taskInfo : deleteTaskInfos) {
			if (taskInfo.isUser()) {
				userappinfo.remove(taskInfo);
			}else{
				systemappinfo.remove(taskInfo);
			}
		}
		//为下次清理进程做准备
		deleteTaskInfos.clear();
		deleteTaskInfos=null;
		//更新界面
		myadapter.notifyDataSetChanged();
	}

	权限
	<uses-permission android:name="android.permission.KILL_BACKGROUND_PROCESSES"/>

#清理细节处理#

	1.设置清理显示
		long memory=0;
		//遍历deleteTaskInfos,分别从userappinfo和systemappinfo中删除deleteTaskInfos中的数据
		for (TaskInfo taskInfo : deleteTaskInfos) {
			if (taskInfo.isUser()) {
				userappinfo.remove(taskInfo);
			}else{
				systemappinfo.remove(taskInfo);
			}
			memory+=taskInfo.getRamSize();
		}
		//数据转化
		String deletesize = Formatter.formatFileSize(getApplicationContext(), memory);
		Toast.makeText(getApplicationContext(), "共清理"+deleteTaskInfos.size()+"个进程,释放"+deletesize+"内存空间", 0).show();
	2.设置当前应用不能选中
		在条目中处理
				//3.根据之前保存的checkbox的状态设置点击之后的状态,原先选中,点击之后不选中
				if (taskInfo.isChecked()) {
					taskInfo.setChecked(false);
				}else{
					//如果是当前应用不能设置成true
					if (!taskInfo.getPackageName().equals(getPackageName())) {
						taskInfo.setChecked(true);
					}
				}
		在全选中处理
			//用户进程
			for (int i = 0; i < userappinfo.size(); i++) {
				if (!userappinfo.get(i).getPackageName().equals(getPackageName())) {
					userappinfo.get(i).setChecked(true);
				}
			}
	3.设置当前应用的checkbox隐藏
		//判断如果是我们的应用程序,就把checkbox隐藏,不是的话显示,在getview中有if必须有else
			if (taskinfo.getPackageName().equals(getPackageName())) {
				viewHolder.cb_itemtaskmanager_ischecked.setVisibility(View.INVISIBLE);
			}else{
				viewHolder.cb_itemtaskmanager_ischecked.setVisibility(View.VISIBLE);
			}

##Day11##

#运行进程个数以及剩余总内存#  (重点:sdk版本)

	1.获取操作
		public class TaskUtil {
			/**
			 * 获取正在运行的进程的个数
			 * @return
			 */
			public static int getProcessCount(Context context){
				ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
				List<RunningAppProcessInfo> runningAppProcesses = am.getRunningAppProcesses();
				return runningAppProcesses.size();
			}
			/**
			 * 获取剩余内存
			 * @return
			 */
			public static long getAvailableRam(Context context){
				ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
				//获取内存的信息,保存到memoryinfo中
				MemoryInfo outInfo = new MemoryInfo();
				am.getMemoryInfo(outInfo);
				//获取空闲的内存
				//outInfo.availMem;
		//		//获取总的内存
		//		outInfo.totalMem;
				return outInfo.availMem;
			}
			
			/**
			 * 获取总的内存
			 * @return
			 * @deprecated
			 */
			public static long getTotalRam(Context context){
				ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
				//获取内存的信息,保存到memoryinfo中
				MemoryInfo outInfo = new MemoryInfo();
				am.getMemoryInfo(outInfo);
				//获取空闲的内存
				//outInfo.availMem;
		//		//获取总的内存
		//		outInfo.totalMem;
				return outInfo.totalMem;//16版本之上才有,之下是没有的
			}
			/**
			 * 兼容低版本
			 * @return
			 */
			public static long getTotalRam(){
				File file = new File("/proc/meminfo");
				StringBuilder sb = new StringBuilder();
				try {
					//读取文件
					BufferedReader br = new BufferedReader(new FileReader(file));
					String readLine = br.readLine();
					//获取数字
					char[] charArray = readLine.toCharArray();
					for (char c : charArray) {
						if (c>='0' && c<='9') {
							sb.append(c);
						}
					}
					String string = sb.toString();
					//转化成long
					long parseLong = Long.parseLong(string);
					return parseLong*1024;
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				} catch (IOException e) {
					e.printStackTrace();
				}
				return 0;
			}
		}
	2.使用
		tv_taskmanager_processes = (TextView) findViewById(R.id.tv_taskmanager_processes);
		tv_taskmanager_freeandtotalram = (TextView) findViewById(R.id.tv_taskmanager_freeandtotalram);

		// 设置显示数据
		// 获取相应的数据
		// 获取运行的进程个数
		processCount = TaskUtil.getProcessCount(getApplicationContext());
		tv_taskmanager_processes.setText("运行中进程:\n" + processCount + "个");
		// 获取剩余,总内存'
		long availableRam = TaskUtil.getAvailableRam(getApplicationContext());
		// 数据转化
		String availaRam = Formatter.formatFileSize(getApplicationContext(),
				availableRam);
		// 获取总内存
		// 根据不同的sdk版去调用不同的方法
		// 1.获取当前的sdk版本
		int sdk = android.os.Build.VERSION.SDK_INT;
		long totalRam;
		if (sdk >= 16) {
			totalRam = TaskUtil.getTotalRam(getApplicationContext());
		} else {
			totalRam = TaskUtil.getTotalRam();
		}
		// 数据转化
		String totRam = Formatter.formatFileSize(getApplicationContext(),
				totalRam);
		tv_taskmanager_freeandtotalram.setText("剩余/总内存:\n" + availaRam + "/"
				+ totRam);
	3.清理操作
		// 更改运行中的进程个数以及剩余总内存
		processCount = processCount - deleteTaskInfos.size();
		tv_taskmanager_processes.setText("运行中进程:\n" + processCount + "个");

		// 更改剩余总内存,重新获取剩余总内存
		// 获取剩余,总内存'
		long availableRam = TaskUtil.getAvailableRam(getApplicationContext());
		// 数据转化
		String availaRam = Formatter.formatFileSize(getApplicationContext(),
				availableRam);
		// 获取总内存
		// 根据不同的sdk版去调用不同的方法
		// 1.获取当前的sdk版本
		int sdk = android.os.Build.VERSION.SDK_INT;
		long totalRam;
		if (sdk >= 16) {
			totalRam = TaskUtil.getTotalRam(getApplicationContext());
		} else {
			totalRam = TaskUtil.getTotalRam();
		}
		// 数据转化
		String totRam = Formatter.formatFileSize(getApplicationContext(),
				totalRam);
		tv_taskmanager_freeandtotalram.setText("剩余/总内存:\n" + availaRam + "/"
				+ totRam);


#桌面小控件#

	1.创建appwidgetprovider
		public class MyWidget extends AppWidgetProvider {

		}
	2.清单文件配置
		 <receiver android:name="com.example.widgets.MyWidget" >
            <intent-filter>
                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
            </intent-filter>

            <meta-data
                android:name="android.appwidget.provider"
                android:resource="@xml/example_appwidget_info" />
        </receiver>
	3.xml -> xxx.xml
		<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
		    android:minWidth="275dp"
		    android:minHeight="72dp"
		    android:updatePeriodMillis="0"
		    android:initialLayout="@layout/example_appwidget"
		    android:resizeMode="horizontal|vertical"
		    >
		</appwidget-provider>
		
		<!-- 
			minWidth,minHeight : 最小的宽高
			updatePeriodMillis : 更新时间,毫秒值,最短不能小于30分钟,设置0跟30分钟一个效果
			previewImage : 预览图片,不设置默认使用应用图标
			initialLayout :widget布局文件
			configure : 可选数据,创建widget之后会启动那个activity
			resizeMode : 设置widget显示尺寸规则,主要用来设置屏幕横竖屏切换保证widget布局不会变形
			widgetCategory : 设置widget显示在什么地方 ,home_screen : 桌面    keyguard:键盘
			initialKeyguardLayout : 设置锁屏的时候显示控件的布局
		 -->
	4.带有@Remoteview注解控件是可以显示在桌面小控件上的


#桌面小控件生命周期#

	第一次创建
		10-20 02:08:34.418: I/System.out(4570): onReceive
		10-20 02:08:34.418: I/System.out(4570): onEnabled
		10-20 02:08:34.418: I/System.out(4570): onReceive
		10-20 02:08:34.418: I/System.out(4570): onUpdate
		10-20 02:08:37.788: I/System.out(4570): onReceive
	第二次创建
		10-20 02:09:27.292: I/System.out(4570): onReceive
		10-20 02:09:27.292: I/System.out(4570): onUpdate
		10-20 02:09:31.439: I/System.out(4570): onReceive
	第三次创建
		10-20 02:09:56.408: I/System.out(4570): onReceive
		10-20 02:09:56.408: I/System.out(4570): onUpdate
		10-20 02:10:00.769: I/System.out(4570): onReceive
	第一次删除
		10-20 02:10:28.303: I/System.out(4570): onReceive
		10-20 02:10:28.303: I/System.out(4570): onDeleted
	第二次删除
		10-20 02:10:45.319: I/System.out(4570): onReceive
		10-20 02:10:45.319: I/System.out(4570): onDeleted
	删除最后一个
		10-20 02:11:09.370: I/System.out(4570): onReceive
		10-20 02:11:09.370: I/System.out(4570): onDeleted
		10-20 02:11:09.380: I/System.out(4570): onReceive
		10-20 02:11:09.380: I/System.out(4570): onDisabled

	1.第一次创建的时候调用onEnabled
	2.不管什么操作都会调用onReceive
	3.每次创建都会调用onUpdate
	4.每次删除都会调用onDeleted
	5.删除最后一个会调用onDisabled

#桌面小控件移植到手机卫士# (重点:反编译+如何找资源控件)

	1.反编译金山卫士apk
	2.根据广播事件去清单文件中找widget
	3.根据元数据找到xml -> xxx.xml
	4.根据xxx.xml下initialLayout找到布局文件
	5.拷贝布局文件,根据错误进行修改

#更新widget中textview#

	1.创建服务
	2.在widget的onEnabled开启服务,在onDisabled关闭服务
	3.更新
		//widget的管理者
		appWidgetManager = AppWidgetManager.getInstance(this);

		/**
		 * 更新widget
		 */
		private void updateWidgets() {
			/*new Thread(){
				public void run() {
					while(true){
						SystemClock.sleep(2000);
					}
				};
			}.start();*/
			//计数器
			Timer timer = new Timer();
			//执行操作
			//task : 要执行操作
			//when : 延迟的时间
			//period : 每次执行的间隔时间
			timer.schedule(new TimerTask() {
				
				@Override
				public void run() {
					//更新操作
					//获取组件的标示
					ComponentName provider = new ComponentName(WidgetService.this, MyWidget.class);
					//获取远程布局
					//packageName : 应用的包名
					//layoutId :widget布局文件
					RemoteViews views = new RemoteViews(getPackageName(), R.layout.process_widget);
					//远程布局不能通过findviewbyid获取初始化控件
					//更新布局文件中相应控件的值
					//viewId :更新控件的id
					//text : 更新的内容
					views.setTextViewText(R.id.process_count, "正在运行软件:"+TaskUtil.getProcessCount(WidgetService.this));
					views.setTextViewText(R.id.process_memory, "可用内存:"+Formatter.formatFileSize(WidgetService.this, TaskUtil.getAvailableRam(WidgetService.this)));
					//更新操作
					appWidgetManager.updateAppWidget(provider, views);
				}
			}, 2000, 2000);
		}


#一键清理# (重点:发送自定义广播+接受自定义广播+pendingIntente)

	1.在timer中进行操作
		//pendingIntent : 延迟意图  包含一个intent意图,当点击的才去执行这个意图,不点击就不执行意图
		views.setOnClickPendingIntent(R.id.btn_clear, pendingIntent);
	2.创建pendingIntent
		//通过发送一个广播去表示要执行清理操作,通过接受发送的广播执行清理操作
		//flags : 指定信息的标签
		PendingIntent pendingIntent = PendingIntent.getBroadcast(WidgetService.this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
	3.pedingintent中需要intent,创建intent,设置发送广播事件
		//按钮点击事件
		Intent intent = new Intent();
		intent.setAction("aa.bb.cc");//设置要发送的广播,aa.bb.cc:自定义的广播事件
		//sendBroadcast(intent);
	4.创建清理进程广播接受者接受广播
		a.创建广播接受者
			/**
			 * 清理进程的广播接受者
			 * @author Administrator
			 *
			 */
			private class WidgetReceiver extends BroadcastReceiver{
		
				@Override
				public void onReceive(Context context, Intent intent) {
					//清理进程
					killProcess();
				}
			}
		b.注册广播接受者
			//注册清理进程广播接受者
			//1.广播接受者
			widgetReceiver = new WidgetReceiver();
			//2.设置接受的广播事件
			IntentFilter intentFilter = new IntentFilter();
			intentFilter.addAction("aa.bb.cc");
			//3.注册广播接受者
			registerReceiver(widgetReceiver, intentFilter);
		c.注销广播接受者
			//注销清理进程的广播接受者
			if (widgetReceiver != null) {
				unregisterReceiver(widgetReceiver);
				widgetReceiver = null;
			}
		d.清理进程
			/**
			 * 清理进程
			 */
			public void killProcess() {
				ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
				//获取正在运行进程
				List<RunningAppProcessInfo> runningAppProcesses = am.getRunningAppProcesses();
				for (RunningAppProcessInfo runningAppProcessInfo : runningAppProcesses) {
					//判断我们的应用进程不能被清理
					if (!runningAppProcessInfo.processName.equals(getPackageName())) {
						am.killBackgroundProcesses(runningAppProcessInfo.processName);
					}
				}
			}
	5.关闭服务的,停止更新
		//停止更新widget
		if (timer != null) {
			timer.cancel();
			timer = null;
		}

#隐藏显示系统进程#

	1.创建一个标示
		//是否显示系统进程的标示
		private boolean isshowSystem = true;
	2.在adapter的getCount方法根据标示设置显示的条目个数
		@Override
		public int getCount() {
			// TODO Auto-generated method stub
			// list.size() = userappinfo.size()+systemappinfo.size()
			return isshowSystem==true ? userappinfo.size() + 1 + systemappinfo.size() + 1 : userappinfo.size() + 1;
		}
	3.在设置的点击事件中更改标示
		/**
		 * 设置
		 * 
		 * @param v
		 */
		public void setting(View v) {
			//true 改为false  false改为true
			isshowSystem = !isshowSystem;
			//更新界面
			myadapter.notifyDataSetChanged();
		}

#锁屏和解锁的操作#  (重点)

	android锁屏和解锁广播接受者比较特别,不能在清单文件中注册,比如通过代码去注册

	1.锁屏清理进程
		a.代码注册锁屏的广播接受者
			/**
			 * 锁屏的广播接受者
			 * @author Administrator
			 *
			 */
			private class ScreenOffReceiver extends BroadcastReceiver{
		
				@Override
				public void onReceive(Context context, Intent intent) {
					System.out.println("锁屏了.....");
					
				}
			}
		b.注册
			/**
			 * 锁屏的广播接受者
			 * @author Administrator
			 *
			 */
			private class ScreenOffReceiver extends BroadcastReceiver{
		
				@Override
				public void onReceive(Context context, Intent intent) {
					System.out.println("锁屏了.....");
					//清理进程
					killProcess();
					//停止更新
					stopUpdates();
				}
			}
		c.注销
			if (screenOffReceiver != null) {
				unregisterReceiver(screenOffReceiver);
				screenOffReceiver = null;
			}
		d.锁屏清理进程
				@Override
				public void onReceive(Context context, Intent intent) {
					System.out.println("锁屏了.....");
					//清理进程
					killProcess();
				}
	2.锁屏停止更新,解锁重新更新
		a.在锁屏中停止更新
			/**
			 * 锁屏的广播接受者
			 * @author Administrator
			 *
			 */
			private class ScreenOffReceiver extends BroadcastReceiver{
		
				@Override
				public void onReceive(Context context, Intent intent) {
					System.out.println("锁屏了.....");
					//清理进程
					killProcess();
					//停止更新
					stopUpdates();
				}
			}
		b.注册解锁的广播接受者
			//注册解锁的广播接受者
			screenOnReceiver = new ScreenOnReceiver();
			IntentFilter screenOnIntentFilter = new IntentFilter();
			screenOnIntentFilter.addAction(Intent.ACTION_SCREEN_ON);
			registerReceiver(screenOnReceiver, screenOnIntentFilter);
		c.解锁重新进行更新
			/**
			 * 解锁的广播接受者
			 * @author Administrator
			 *
			 */
			private class ScreenOnReceiver extends BroadcastReceiver{
		
				@Override
				public void onReceive(Context context, Intent intent) {
					updateWidgets();
				}
			}

#widgetBug解决#

	将onEnabled开启服务的操作,移植onUpdate方法中,因为更新时间到了之后就会调用onUpdate方法

#屏幕适配# (重点)

	1.dp -> px
		public class DensityUtil {
			/** 
		     * 根据手机的分辨率从 dip 的单位 转成为 px(像素) 
			 * @return 
		     */  
		    public static int dip2qx(Context context, float dpValue) {  
		        final float scale = context.getResources().getDisplayMetrics().density;  //获取屏幕的密度
		        return (int) (dpValue * scale + 0.5f); //+0.5f四舍五入   3.7  3   3.7+0.5 = 4.2   4
		    }  
		  
		    /** 
		     * 根据手机的分辨率从 px(像素) 的单位 转成为 dp 
		     */  
		    public static int px2dip(Context context, float pxValue) {  
		        final float scale = context.getResources().getDisplayMetrics().density;  
		        return (int) (pxValue / scale + 0.5f);  
		    }  
		}
	2.ScrollView
		<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:itheima="http://schemas.android.com/apk/res/com.itheima.mobliesafe75"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent" >
			<!-- ScrollView : 只能有一个子控件 -->


#创建快捷方式#  (重点)

	/**
	 * 创建快捷方式
	 */
	private void shortcut() {
		if (sp.getBoolean("firstshortcut", true)) {
			// 给桌面发送一个广播
			Intent intent = new Intent(
					"com.android.launcher.action.INSTALL_SHORTCUT");
			// 设置属性
			// 设置快捷方式名称
			intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, "手机卫士75");
			// 设置快捷方式的图标
			Bitmap value = BitmapFactory.decodeResource(getResources(),
					R.drawable.ic_launcher);
			intent.putExtra(Intent.EXTRA_SHORTCUT_ICON, value);
			// 设置快捷方式执行的操作
			Intent intent2 = new Intent();
			intent2.setAction("com.itheima.mobliesafe75.home");
			intent2.addCategory("android.intent.category.DEFAULT");
			intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, intent2);
			sendBroadcast(intent);
			
			//保存已经创建快捷方式的状态
			Editor edit = sp.edit();
			edit.putBoolean("firstshortcut", false);
			edit.commit();
		}
	}


#监听用户代开应用程序#  (重点)

	时时刻刻监听某些操作行为  ,  watch dog   看门狗

		//时时刻刻监听用户打开的程序
		//activity都是存放在任务栈中的,一个应用只有一个任务栈
		final ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
		new Thread(){
			public void run() {
				while(true){
					//监听操作
					//监听用户打开了哪些任务栈,打开哪些应用
					//获取正在运行的任务栈,如果任务栈运行,就表示应用打开过
					//maxNum : 获取正在运行的任务栈的个数
					//现在打开的应用的任务栈,永远在第一个,而之前(点击home最小化,没有退出)的应用的任务栈会依次往后推
					List<RunningTaskInfo> runningTasks = am.getRunningTasks(1);
					System.out.println("----------------------");
					for (RunningTaskInfo runningTaskInfo : runningTasks) {
						//获取任务栈,栈底的activity
						ComponentName baseactivity = runningTaskInfo.baseActivity;
						/*//获取任务栈栈顶的activity
						runningTaskInfo.topActivity;*/
						String packageName = baseactivity.getPackageName();
						System.out.println(packageName);
						if (packageName.equals("com.android.mms")) {
							Intent intent = new Intent(WatchDogService.this,MainActivity.class);
							//因为activity保存在任务栈中,而服务,广播没有保存在任务栈中的,所以在服务,广播中跳转activity必须给activity设置任务栈
							intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
							startActivity(intent);
						}
					}
					System.out.println("----------------------");
					SystemClock.sleep(3000);
				}
			};
		}.start();

#看门狗数据库操作# (重点)

	1.创建数据库
			public class WatchDogOpenHelper extends SQLiteOpenHelper {

					public static final String DB_NAME="info";
					
					public WatchDogOpenHelper(Context context) {
						super(context, "watchdog.db", null, 1);
					}
				
					@Override
					public void onCreate(SQLiteDatabase db) {
						db.execSQL("create table "+DB_NAME+"(_id integer primary key autoincrement,packagename varchar(50))");
					}
				
					@Override
					public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
				
					}
				
			}
	2.操作,拷贝blacknumdao,修改
		public class WatchDogDao {
				
				private WatchDogOpenHelper watchDogOpenHelper;
				private byte[] b = new byte[1024];
				//在构造函数中获取BlackNumOpenHlper
				public WatchDogDao(Context context){
					watchDogOpenHelper = new WatchDogOpenHelper(context);
				}
				//增删改查
				//面试:我在同一时刻对数据库既进行读操作也进行写操作,怎么避免这个两个操作同时操作数据库,同步锁+将WatchDogOpenHelper设置成单例模式
				/**
				 * 添加应用程序包名
				 * @param blacknum
				 * @param mode
				 */
				public void addLockApp(String packageName){
			//		synchronized (b) {
						//1.获取数据库
						SQLiteDatabase database = watchDogOpenHelper.getWritableDatabase();
						//2.添加操作
						//ContentValues :　添加的数据
						ContentValues values = new ContentValues();
						values.put("packagename", packageName);
						database.insert(WatchDogOpenHelper.DB_NAME, null, values);
						//3.关闭数据库
						database.close();
			//		}
				}


##Day12##

#加锁解锁#

	1.在item的布局文件中增加imageview
	2.在getview中判断是否加锁
			//判断应用程序是加锁还是解锁
			if (watchDogDao.queryLockApp(appInfo.getPackagName())) {
				//加锁
				viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.lock);
			}else{
				//解锁
				viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.unlock);
			}
	3.使用长按点击事件实现加锁解锁
		/**
		 * 长按点击事件
		 */
		private void listviewItemLongClick() {
			lv_softmanager_application.setOnItemLongClickListener(new OnItemLongClickListener() {
	
				@Override
				public boolean onItemLongClick(AdapterView<?> parent, View view,
						int position, long id) {
					System.out.println("长按点击事件");
					//true if the callback consumed the long click, false otherwise
					//true:表示执行  false:拦截
					//加锁解锁的操作
					//屏蔽用户和系统程序(..个)不能加锁解锁操作
					if (position == 0 || position == userappinfo.size()+1) {
						return true;
					}
					//获取数据
					if (position <= userappinfo.size()) {
						//用户程序
						appInfo = userappinfo.get(position-1);
					}else{
						//系统程序
						appInfo = systemappinfo.get(position - userappinfo.size() - 2);
					}
					//加锁解锁
					ViewHolder viewHolder = (ViewHolder) view.getTag();
					//判断应用有没有加锁,有的解锁,没有的加锁
					if (watchDogDao.queryLockApp(appInfo.getPackagName())) {
						//解锁操作
						watchDogDao.deleteLockApp(appInfo.getPackagName());
						viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.unlock);
					}else{
						//加锁操作
						watchDogDao.addLockApp(appInfo.getPackagName());
						viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.lock);
					}
					//myadapter.notifyDataSetChanged();
					return true;
				}
			});
		}

#监听用户打开程序#

	1.创创建解锁界面
	2.在服务中,监听用户打开程序的操作中,通过查询数据库的方式判断打开的应用程序是否加锁
				//通过查询数据库,如果数据库中有,弹出解锁界面,没有不作处理
						if (watchDogDao.queryLockApp(packageName)) {
							//弹出解锁界面
							Intent intent = new Intent(WatchDogService.this,WatchDogActivity.class);
							intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
							startActivity(intent);
						}
	3.在解锁界面点击返回键,重复弹出解锁界面
		@Override
		public boolean onKeyDown(int keyCode, KeyEvent event) {
			if (keyCode == KeyEvent.KEYCODE_BACK) {
				/**
				 * Starting: Intent { 
				   act=android.intent.action.MAIN 
				   cat=[android.intent.category.HOME
				   ] cmp=com.android.launcher/com.android.launcher2.Launcher } from pid 208
				 */
				//跳转到主界面
				Intent intent = new Intent();
				intent.setAction("android.intent.action.MAIN");
				intent.addCategory("android.intent.category.HOME");
				startActivity(intent);
				finish();
			}
			return super.onKeyDown(keyCode, event);
		}
	4.不能给当前应用程序加锁
				//判断如果是当前应用程序,就不要加锁
					if (!appInfo.getPackagName().equals(getPackageName())) {
						watchDogDao.addLockApp(appInfo.getPackagName());
						viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.lock);
					}else{
						Toast.makeText(getApplicationContext(), "当前的应用程序不能加锁", 0).show();
					}

#解锁界面优化#

	1.在服务跳转activity的操作中将加锁应用程序的包名传递给解锁界面
			Intent intent = new Intent(WatchDogService.this,WatchDogActivity.class);
			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
			intent.putExtra("packageName", packageName);
			startActivity(intent);
	2.在解锁界面获取传递的数据,并通过包名获取图片和名称
		//接受获取数据
		Intent intent = getIntent();
		packagename = intent.getStringExtra("packageName");
		//设置显示加锁的应用程序的图片和名称
		PackageManager pm = getPackageManager();
		try {
			ApplicationInfo applicationInfo = pm.getApplicationInfo(packagename, 0);
			Drawable icon = applicationInfo.loadIcon(pm);
			String name = applicationInfo.loadLabel(pm).toString();
			//设置显示
			iv_watchdog_icon.setImageDrawable(icon);
			tv_watchdog_name.setText(name);
		} catch (NameNotFoundException e) {
			e.printStackTrace();
		}
	3.解决,点击home最小,打开其他加锁程序,显示上一个加锁程序的图片和名称的bug
		@Override
		protected void onStop() {
			super.onStop();
			finish();
		}

#解锁操作#  (重点:发送广播)

	1.通过发送广播的方式,去给服务发送解锁信息
		if ("123".equals(password)) {
			//解锁
			//一般通过广播的形式将信息发送给服务
			Intent intent = new Intent();
			intent.setAction("com.itheima.mobliesafe75.unlock");//自定义发送广播事件
			intent.putExtra("packagename", packagename);
			sendBroadcast(intent);
			finish();
		}else{
			Toast.makeText(getApplicationContext(), "密码错误", 0).show();
		}
	2.在服务中,通过注册广播的形式实现接受信息并进行解锁操作
		注册广播接受者
			//注册解锁的广播接受者
			//1.广播接受者
			unlockCurrentReceiver = new UnlockCurrentReceiver();
			//2.设置接受的广播事件
			IntentFilter intentFilter = new IntentFilter();
			intentFilter.addAction("com.itheima.mobliesafe75.unlock");
		接受信息
			private class UnlockCurrentReceiver extends BroadcastReceiver{
	
				@Override
				public void onReceive(Context context, Intent intent) {
					//解锁操作
					unlockcurrentPackagname = intent.getStringExtra("packagename");
				}
			}
		解锁操作
			//通过查询数据库,如果数据库中有,弹出解锁界面,没有不作处理
			if (watchDogDao.queryLockApp(packageName)) {
				if (!packageName.equals(unlockcurrentPackagname)) {
					//弹出解锁界面
					Intent intent = new Intent(WatchDogService.this,WatchDogActivity.class);
					intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
					intent.putExtra("packageName", packageName);
					startActivity(intent);
				}
			}
		
	3.加锁操作,锁屏之后重新加锁
		a.注册锁屏的广播接受者
			//注册锁屏的广播接受者
			screenOffReceiver = new ScreenOffReceiver();
			IntentFilter screenOffIntentFilter = new IntentFilter();
			screenOffIntentFilter.addAction(Intent.ACTION_SCREEN_OFF);
			registerReceiver(screenOffReceiver, screenOffIntentFilter);
		b.在锁屏的广播接受者中将包名表示设置为null,表示加锁操作
			private class  ScreenOffReceiver extends BroadcastReceiver{

				@Override
				public void onReceive(Context context, Intent intent) {
					//加锁的操作
					unlockcurrentPackagname = null;
				}
			}

#两个bug解决方案#  (重点:启动模式)

	1.启动模式
		<activity android:name=".WatchDogActivity"
            android:launchMode="singleInstance"
            ></activity>
        <!-- 
        	standard : 标准的启动模式
        	singleTop : 如果activity在栈顶,直接使用
        	singleTask : 如果任务栈中有activity的,之前的activity删除,将activity置顶
        	singleInstance : 将activity单独存放一个任务栈中
         -->
	2.从最近列表中删除手机卫士应用
		android:excludeFromRecents="true"
		excludeFromRecents : 是否在最近列表中显示    true:不显示      false:显示,只有设置这个属性的activity运行了,这个属性才会生效

#数据库优化#  (重点:内容观察者)

	1.当数据库发生变化,通知内容观察者进行更新数据,在数据库操作中,比如添加,删除
			//通知内容观察者数据库变化了
			ContentResolver contentResolver = context.getContentResolver();
			//因为是我们自己的数据发生变化了,所以我们要自定义一个uri进行操作
			Uri uri = Uri.parse("content://com.itheima.mobliesafe75.lock.changed");
			//通知内容观察者数据发生变化了
			contentResolver.notifyChange(uri, null);
	2.使用内容观察者进行数据更新操作
				//先将数据库中的数据,查询存放到内存,然后再把数据从内存中获取出来进行操作
				
				//当数据库变化的时候重新更新内存中的数据,当数据库变化的时候通知内容观察者数据库变化了,然后在内容观察者中去更新最新的数据
				Uri uri = Uri.parse("content://com.itheima.mobliesafe75.lock.changed");
				//notifyForDescendents:匹配规则,true:精确匹配  false:模糊匹配
				getContentResolver().registerContentObserver(uri, true, new ContentObserver(null) {
					public void onChange(boolean selfChange) {
						//更新数据
						list = watchDogDao.querAllLockApp();
					};
				});
	3.使用内存中的数据,使用list集合中的数据
						//判断list集合中是否包含包名
						boolean b = list.contains(packageName);
						//通过查询数据库,如果数据库中有,弹出解锁界面,没有不作处理
						if (b) {
							if (!packageName.equals(unlockcurrentPackagname)) {
								//弹出解锁界面
								Intent intent = new Intent(WatchDogService.this,WatchDogActivity.class);
								intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
								intent.putExtra("packageName", packageName);
								startActivity(intent);
							}
						}

#获取短信#

	/**
	 * 获取短信
	 */
	public static void getAllSMS(Context context){
		//1.获取内容解析者
		ContentResolver resolver = context.getContentResolver();
		//2.获取内容提供者地址   sms,sms表的地址:null  不写
		//3.获取查询路径
		Uri uri = Uri.parse("content://sms");
		//4.查询操作
		//projection : 查询的字段
		//selection : 查询的条件
		//selectionArgs : 查询条件的参数
		//sortOrder : 排序
		Cursor cursor = resolver.query(uri, new String[]{"address","date","type","body"}, null, null, null);
		//5.解析cursor
		while(cursor.moveToNext()){
			String address = cursor.getString(0);
			String date = cursor.getString(1);
			String type = cursor.getString(2);
			String body = cursor.getString(3);
			System.out.println("address:"+address+"   date:"+date+"  type:"+type+"  body:"+body);
		}
	}

	权限
	 <uses-permission android:name="android.permission.READ_SMS"/>
     <uses-permission android:name="android.permission.WRITE_SMS"/>

#备份短信#  (重点:创建xml文件)

	1.数据库
	2.文件   xml

	/**
	 * 获取短信
	 */
	public static void getAllSMS(Context context){
		//1.获取短信
		//1.1获取内容解析者
		ContentResolver resolver = context.getContentResolver();
		//1.2获取内容提供者地址   sms,sms表的地址:null  不写
		//1.3获取查询路径
		Uri uri = Uri.parse("content://sms");
		//1.4.查询操作
		//projection : 查询的字段
		//selection : 查询的条件
		//selectionArgs : 查询条件的参数
		//sortOrder : 排序
		Cursor cursor = resolver.query(uri, new String[]{"address","date","type","body"}, null, null, null);
		
		
		//2.备份短信
		//2.1获取xml序列器
		XmlSerializer xmlSerializer = Xml.newSerializer();
		try {
			//2.2设置xml文件保存的路径
			//os : 保存的位置
			//encoding : 编码格式
			xmlSerializer.setOutput(new FileOutputStream(new File("/mnt/sdcard/backupsms.xml")), "utf-8");
			//2.3设置头信息
			//standalone : 是否独立保存
			xmlSerializer.startDocument("utf-8", true);
			//2.4设置根标签
			xmlSerializer.startTag(null, "smss");
			//1.5.解析cursor
			while(cursor.moveToNext()){
				//2.5设置短信的标签
				xmlSerializer.startTag(null, "sms");
				//2.6设置文本内容的标签
				xmlSerializer.startTag(null, "address");
				String address = cursor.getString(0);
				//2.7设置文本内容
				xmlSerializer.text(address);
				xmlSerializer.endTag(null, "address");
				
				xmlSerializer.startTag(null, "date");
				String date = cursor.getString(1);
				xmlSerializer.text(date);
				xmlSerializer.endTag(null, "date");
				
				xmlSerializer.startTag(null, "type");
				String type = cursor.getString(2);
				xmlSerializer.text(type);
				xmlSerializer.endTag(null, "type");
				
				xmlSerializer.startTag(null, "body");
				String body = cursor.getString(3);
				xmlSerializer.text(body);
				xmlSerializer.endTag(null, "body");
				
				xmlSerializer.endTag(null, "sms");
				System.out.println("address:"+address+"   date:"+date+"  type:"+type+"  body:"+body);
				
			}
			xmlSerializer.endTag(null, "smss");
			xmlSerializer.endDocument();
			//2.8将数据刷新到文件中
			xmlSerializer.flush();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
	}

#备份效果#  (重点:progressdialog+回调函数)

	1.progerssdialog
		//progressdialog是可以在子线程中更新
		progressDialog = new ProgressDialog(this);
		progressDialog.setCancelable(false);//不能取消
		progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
		/*progressDialog.setMax(max);//设置最大进度
		progressDialog.setProgress(value);//设置当前进度
		*/progressDialog.show();
	2.使用progerssbar
		progerssbar.setMax(max);//设置最大进度
		progerssbar.setProgress(value)

	回调函数
		1.创建刷子
			public interface ShowProgress{
				//设置最大进度
				public void setMax(int max);
				//设置当前进度
				public void setProgress(int progerss);
			}
		2.媳妇儿给你刷子
			public static void getAllSMS(Context context,ShowProgress showProgress){
		
				//设置最大进度
				int count = cursor.getCount();//获取短信的个数
				showProgress.setMax(count);


				//设置当前进度
				progress++;
				showProgress.setProgress(progress);
			}
		3.我们接受刷子,进行刷牙,刷鞋,刷马桶.....
				SMSEngine.getAllSMS(getApplicationContext(),new ShowProgress() {
					
					@Override
					public void setProgress(int progerss) {
						//progressDialog.setProgress(progerss);
						pb_atools_sms.setProgress(progerss);
					}
					
					@Override
					public void setMax(int max) {
						//progressDialog.setMax(max);
						pb_atools_sms.setMax(max);
					}
				});	


#短信还原#

	/**
	 * 短信还原
	 * @param v
	 */
	public void restoresms(View v){
		//解析xml
		//XmlPullParser xmlPullParser = Xml.newPullParser();
		//插入短信
		ContentResolver resolver = getContentResolver();
		Uri uri = Uri.parse("content://sms");
		ContentValues values = new ContentValues();
		values.put("address", "95588");
		values.put("date", System.currentTimeMillis());
		values.put("type", 1);
		values.put("body", "zhuan zhang le $10000000000000000000");
		resolver.insert(uri, values);
	}

#可扩展的listview#

	1.布局文件中
		<ExpandableListView 
	    android:id="@+id/exlitview"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    ></ExpandableListView>
	2.使用
		exlitview = (ExpandableListView) findViewById(R.id.exlitview);
		exlitview.setAdapter(new MyAdapter());

		private class MyAdapter extends BaseExpandableListAdapter{
				//获取组的个数
				@Override
				public int getGroupCount() {
					// TODO Auto-generated method stub
					return 8;
				}
				//获取每组孩子的个数
				@Override
				public int getChildrenCount(int groupPosition) {
					// TODO Auto-generated method stub
					return groupPosition+1;
				}
				//设置组对应的相应的信息
				@Override
				public Object getGroup(int groupPosition) {
					// TODO Auto-generated method stub
					return null;
				}
				//设置每组孩子对应的信息
				//groupPosition ：组的位置
				//childPosition : 孩子的位置
				@Override
				public Object getChild(int groupPosition, int childPosition) {
					// TODO Auto-generated method stub
					return null;
				}
				//获取组的id
				@Override
				public long getGroupId(int groupPosition) {
					// TODO Auto-generated method stub
					return 0;
				}
				//获取每组孩子的id
				@Override
				public long getChildId(int groupPosition, int childPosition) {
					// TODO Auto-generated method stub
					return 0;
				}
				//获取id是否稳定,有没有设置id,有设置,返回true,没有设置返回false
				@Override
				public boolean hasStableIds() {
					// TODO Auto-generated method stub
					return false;
				}
				//设置组的样式
				@Override
				public View getGroupView(int groupPosition, boolean isExpanded,
						View convertView, ViewGroup parent) {
					TextView textView = new TextView(getApplicationContext());
					textView.setText("         我是第"+groupPosition+"组");
					textView.setTextColor(Color.RED);
					return textView;
				}
				//设置每组孩子样式
				@Override
				public View getChildView(int groupPosition, int childPosition,
						boolean isLastChild, View convertView, ViewGroup parent) {
					
					TextView textView = new TextView(getApplicationContext());
					textView.setText("我是第"+groupPosition+"组的第"+childPosition+"个孩子");
					textView.setTextColor(Color.GREEN);
					return textView;
				}
				//设置孩子是否能够被点击,true:可以   false:不可以
				@Override
				public boolean isChildSelectable(int groupPosition, int childPosition) {
					// TODO Auto-generated method stub
					return false;
				}
				
			}

#抽屉效果#  (重点)

	slidingmenu  第三方法框架

	1.SlidingDrawer
		<SlidingDrawer 
	        android:layout_width="match_parent"
	        android:layout_height="match_parent"
	        android:handle="@+id/handle"
	        android:content="@+id/content"
	        android:orientation="vertical"
	        >
	        <LinearLayout 
	             android:id="@+id/handle"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            >
	            <ImageView 
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:src="@drawable/shenmabg"
	            />
	        </LinearLayout>
	        <LinearLayout 
	            android:id="@+id/content"
	            android:layout_width="match_parent"
	            android:layout_height="match_parent"
	            android:background="#ff0000"
	            ></LinearLayout>
	    </SlidingDrawer>
		
	2.android.support.v4.widget.DrawerLayout
		<android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent"
		    android:orientation="vertical" 
		    android:id="@+id/dl"
		    >
		
		   <RelativeLayout 
		       android:layout_width="match_parent"
		       android:layout_height="match_parent"
		       >
		    <TextView
		        android:id="@+id/textView1"
		        android:layout_width="match_parent"
		        android:layout_height="wrap_content"
		        android:text="流量统计" 
		        android:background="#8866ff00"
		        android:gravity="center_horizontal"
		        android:textSize="22sp"
		        android:paddingTop="5dp"
		        android:paddingBottom="5dp"
		        />
		    </RelativeLayout>
		    <!-- layout_gravity : 在布局中决定控件存在位置 -->
		    <LinearLayout 
		        android:layout_width="match_parent"
		        android:layout_height="match_parent"
		        android:layout_gravity="right"
		        android:background="#ff0000"
		        ></LinearLayout>
		    <LinearLayout 
		        android:layout_width="match_parent"
		        android:layout_height="match_parent"
		        android:layout_gravity="left"
		        android:background="#0000ff"
		        ></LinearLayout>
        
	

	代码中使用
		DrawerLayout dl = (DrawerLayout) findViewById(R.id.dl);
//		dl.openDrawer(Gravity.RIGHT);//表示默认打开哪个方向布局
		dl.openDrawer(Gravity.LEFT);

##Day13##

#病毒#

	病毒 : 一段带有恶意行为的计算机程序
	恶搞 : 炫耀技术,熊猫烧香,损人不利己
	灰鸽子 : 盗号,qq,游戏账号
	肉机 : 通过一段程序控制的电脑
	
	杀毒软件历史
		1.黑名单  : 将已有的病毒保存到数据库中,卡巴斯基,江民,瑞星,金山,问题:不能及时发现病毒,蜜罐,云查杀
		2.白名单  : 360  把查杀过的应用发送数据库中

	手机端:黑名单

#手机杀毒界面#

	layer-list : 图层,帧布局framlayout,可以将图片一层叠一层展示,布局文件中最下面的控件,显示的时候在最上面

	1.布局
			<RelativeLayout 
	        android:layout_width="match_parent"
	        android:layout_height="wrap_content"
	        >
	        <ImageView 
	            android:id="@+id/iv_antivirus_anitimageview"
	            android:layout_width="80dp"
	            android:layout_height="80dp"
	            android:src="@drawable/ic_scanner_malware"
	            android:layout_margin="10dp"
	            />
	        <ImageView 
	            android:id="@+id/iv_antivirus_scanner"
	            android:layout_width="80dp"
	            android:layout_height="80dp"
	            android:src="@drawable/act_scanning_03"
	            android:layout_margin="10dp"
	            />
	        <TextView 
	            android:id="@+id/tv_antivirus_text"
	            android:layout_width="match_parent"
	            android:layout_height="wrap_content"
	            android:text="正在扫描..."
	            android:layout_toRightOf="@id/iv_antivirus_anitimageview"
	            android:layout_marginTop="25dp"
	            android:textSize="18sp"
	            android:layout_marginRight="15dp"
	            />
			<!-- progress : 设置进度条当前进度 -->
	        <ProgressBar
	            android:id="@+id/pb_antivirus_progressbar"
	            style="?android:attr/progressBarStyleHorizontal"
	            android:layout_width="match_parent"
	            android:layout_height="wrap_content"
	            android:layout_below="@id/tv_antivirus_text"
	            android:layout_toRightOf="@id/iv_antivirus_anitimageview"
	            android:layout_marginTop="5dp"
	            android:layout_marginRight="15dp"
	            android:progressDrawable="@drawable/progerssbar_antivirus_bg"
	            android:progress="30"
	            />
	
	    </RelativeLayout>
	2.图层  res->drawable -> xxx.xml
		<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
		    <item android:id="@android:id/background">
		      <bitmap android:src="@drawable/security_progress_bg"
		        android:gravity="center" />
		    </item>
		    <item android:id="@android:id/secondaryProgress">
		      <bitmap android:src="@drawable/security_progress"
		        android:gravity="center" />
		    </item>
		    <item android:id="@android:id/progress">
		      <bitmap android:src="@drawable/security_progress"
		        android:gravity="center" />
		    </item>
		</layer-list>
	3.更改样式,progressbar的属性
		android:progressDrawable="@drawable/progerssbar_antivirus_bg"


#扫描操作#  (重点:动画)


		//设置旋转动画
		//fromDegrees : 旋转开始的角度
		//toDegrees : 结束的角度
		//后面四个:是以自身变化还是以父控件变化
		//Animation.RELATIVE_TO_SELF : 以自身旋转
		//Animation.RELATIVE_TO_PARENT : 以父控件旋转
		RotateAnimation rotateAnimation = new RotateAnimation(0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
		rotateAnimation.setDuration(1000);//持续时间
		rotateAnimation.setRepeatCount(Animation.INFINITE);//设置旋转的次数,INFINITE:一直旋转
		
		//设置动画插补器
		LinearInterpolator linearInterpolator = new LinearInterpolator();
		rotateAnimation.setInterpolator(linearInterpolator);
		iv_antivirus_scanner.startAnimation(rotateAnimation);

	展示软件列表  1.listview   2.linearlayout添加textview
		
    /**
	 * 扫描程序
	 */
	private void scanner() {
		//1.获取包的管理者
		final PackageManager pm = getPackageManager();
		tv_antivirus_text.setText("正在初始化64核杀毒引擎....");
		new Thread(){
			public void run() {
				//延迟一秒中扫描程序
				SystemClock.sleep(100);
				//2.获取所有安装应用程序信息
				List<PackageInfo> installedPackages = pm.getInstalledPackages(0);
				
				//3.1设置进度条最大进度
				pb_antivirus_progressbar.setMax(installedPackages.size());
				//3.2设置当前进度
				int count=0;
				for (PackageInfo packageInfo : installedPackages) {
					SystemClock.sleep(100);
					//3.设置进度条的最大进度和当前进度
					count++;
					pb_antivirus_progressbar.setProgress(count);
					
					//4.设置扫描显示软件名称
					final String name = packageInfo.applicationInfo.loadLabel(pm).toString();
					//在ui线程(主线程)进行操作
					runOnUiThread(new Runnable() {//封装了handler
						
						@Override
						public void run() {
							tv_antivirus_text.setText("正在扫描:"+name);
							
							//6.展示扫描软件的名称信息
							TextView textView = new TextView(getApplicationContext());
							textView.setTextColor(Color.BLACK);
							textView.setText(name);
							//textview添加到线性布局中
							//ll_antivirus_safeapks.addView(textView);
							ll_antivirus_safeapks.addView(textView, 0);//index:将textview添加到线性布局的哪个位置
						}
					});
				};
				//5.扫描完成,显示扫描完成信息,同时旋转动画停止
				runOnUiThread(new Runnable() {
					
					@Override
					public void run() {
						//设置显示信息以及停止动画
						tv_antivirus_text.setText("扫描完成,未发现病毒");
						iv_antivirus_scanner.clearAnimation();//移出动画
					}
				});
			};
		}.start();
	}

#获取签名信息# (重点:指定信息的标签)

	1.指定获取签名信息标签
		List<PackageInfo> installedPackages = pm.getInstalledPackages(PackageManager.GET_SIGNATURES);
	2.获取签名信息
		//7.获取应用程序的签名,并进行md5加密
		Signature[] signatures= packageInfo.signatures;//获取应用程序的签名信息,获取签名的数组
		String charsString = signatures[0].toCharsString();
		//对签名信息进行MD5加密
		String signature = MD5Util.passwordMD5(charsString);
		System.out.println(name+"  : "+signature);

#手机杀毒#

	1.将病毒库导入到手机中,参考splashactivity中拷贝数据库操作,增加方法传递参数
	2.创建查询数据库操作
			//查询Md5值是否在数据库中
			public class AntiVirusDao {
				/**
				 * 查询Md5值是否在病毒数据库中
				 * @param context
				 * @param md5
				 * @return
				 */
				public static boolean queryAntiVirus(Context context,String md5){
					boolean ishave = false;
					//1.获取数据库的路径
					File file = new File(context.getFilesDir(), "antivirus.db");
					SQLiteDatabase database = SQLiteDatabase.openDatabase(file.getAbsolutePath(), null, SQLiteDatabase.OPEN_READONLY);
					Cursor cursor = database.query("datable", null, "md5=?", new String[]{md5}, null, null, null);
					if (cursor.moveToNext()) {
						ishave = true;
					}
					cursor.close();
					database.close();
					return ishave;
				}
			}
	3.使用
		//8.查询MD5值是否在病毒数据库中
		boolean b = AntiVirusDao.queryAntiVirus(getApplicationContext(), signature);
	4.根据查询值,设置病毒标示
		//6.展示扫描软件的名称信息
		TextView textView = new TextView(getApplicationContext());
		//9.根据返回的值将病毒标示出来
		if (b) {
			//有病毒
			textView.setTextColor(Color.RED);
			//将病毒的包名添加到list集合
			list.add(packageInfo.packageName);
		}else{
			//没有病毒
			textView.setTextColor(Color.BLACK);
		}
		textView.setText(name);
	5.对查询到病毒进行处理
						//10.根据是否有病毒进行显示操作
						if (list.size() > 0) {
							//有病毒
							tv_antivirus_text.setText("扫描完成,发现"+list.size()+"个病毒");
							//卸载病毒应用
							AlertDialog.Builder builder = new Builder(AntivirusActivity.this);
							builder.setTitle("提醒!发现"+list.size()+"个病毒");
							builder.setIcon(R.drawable.ic_launcher);
							builder.setMessage("是否卸载病毒应用!");
							builder.setPositiveButton("卸载", new DialogInterface.OnClickListener() {
								
								@Override
								public void onClick(DialogInterface dialog, int which) {
									//卸载操作
									for (String packagname : list) {
										Intent intent = new Intent();
										intent.setAction("android.intent.action.DELETE");
										intent.addCategory("android.intent.category.DEFAULT");
										intent.setData(Uri.parse("package:"+packagname));
										startActivity(intent);
									}
									dialog.dismiss();
								}
							});
							builder.setNegativeButton("取消", null);
							builder.show();
						}else{
							//设置显示信息以及停止动画
							tv_antivirus_text.setText("扫描完成,未发现病毒");
						}

#缓存清理框架# (重点!!!!!!)

	1.将activity改为继承fragmentActivity
		//如果要对fragment进行管理操作,activity必须继承fragmentActivity
		public class ClearCacheActivity extends FragmentActivity {
		}
	2.设置布局文件
		!-- fragment替换的控件 -->
	    <FrameLayout 
	        android:id="@+id/fram_clearcache_fragment"
	        android:layout_width="match_parent"
	        android:layout_height="match_parent"
	        android:layout_weight="1"
	        ></FrameLayout>
	   <LinearLayout 
	       android:layout_width="match_parent"
	       android:layout_height="wrap_content"
	       >
	    
	    <Button 
	        android:layout_width="0dp"
	        android:layout_weight="1"
	        android:layout_height="wrap_content"
	        android:text="缓存清理"
	        android:background="@drawable/selector_contact_button"
	        android:onClick="cache"
	        />
	    
	    <Button 
	        android:layout_width="0dp"
	        android:layout_weight="1"
	        android:layout_height="wrap_content"
	        android:text="SD卡清理"
	         android:background="@drawable/selector_contact_button"
	         android:onClick="sd"
	        />
	    </LinearLayout>
	3.创建fragment
		public class CacheFragment extends Fragment {
			//初始化操作
			@Override
			public void onCreate(Bundle savedInstanceState) {
				// TODO Auto-generated method stub
				super.onCreate(savedInstanceState);
			}
			//设置fragment的布局
			@Override
			public View onCreateView(LayoutInflater inflater, ViewGroup container,
					Bundle savedInstanceState) {
				//参数1:布局文件
				//参数2:容器
				//参数3:自动挂载  ,一律false
				View view= inflater.inflate(R.layout.fragment_cache, container, false);
				return view;
			}
			//设置填充显示数据
			@Override
			public void onActivityCreated(Bundle savedInstanceState) {
				// TODO Auto-generated method stub
				super.onActivityCreated(savedInstanceState);
			}
			
		}
	4.创建fragment布局文件,线性布局,背景是红色
	5.在actiivty中添加fragment
		@Override
		protected void onCreate(Bundle savedInstanceState) {
			super.onCreate(savedInstanceState);
			setContentView(R.layout.activity_clearcache);
			
			//挂载fragment
			//1.获取fragment
			cacheFragment = new CacheFragment();
			sdFragment = new SDFragment();
			//2.加载fragment
			//2.1获取fragment的管理者
			supportFragmentManager = getSupportFragmentManager();
			//2.2开启事务
			FragmentTransaction beginTransaction = supportFragmentManager.beginTransaction();
			//2.3添加fragment操作
			//数据不会重新刷新
			//参数1:fragment要替换的控件的id
			//参数2:要替换fragment
			beginTransaction.add(R.id.fram_clearcache_fragment, cacheFragment);
			//界面展示以最后一个添加的为准
			beginTransaction.add(R.id.fram_clearcache_fragment, sdFragment);
			//隐藏fragment操作
			beginTransaction.hide(sdFragment);
			//也可以实现替换操作,数据会重新刷新
			//beginTransaction.replace(arg0, arg1)
			//2.4提交事务
			beginTransaction.commit();
		}
	6.隐藏显示fragment操作
		//缓存清理
		public void cache(View v){
			//隐藏sdfragment,显示cacheFragment
			//1.获取事务
			FragmentTransaction beginTransaction = supportFragmentManager.beginTransaction();
			//2.隐藏显示操作
			beginTransaction.hide(sdFragment);//隐藏fragmnt
			beginTransaction.show(cacheFragment);//显示fragment操作
			//3.提交
			beginTransaction.commit();
		}

#缓存清理扫描操作#

	/**
	 * 扫描
	 */
	private void scanner() {
		//1.获取包的管理者
		//getActivity() : 获取fragment所在的activity
		final PackageManager pm = getActivity().getPackageManager();
		tv_cachefragment_text.setText("正在初始化128核扫描引擎.....");
		new Thread(){
			public void run() {
				SystemClock.sleep(100);
				List<PackageInfo> installedPackages = pm.getInstalledPackages(0);
				//设置进度条最大进度
				pb_cachefragment_progressbar.setMax(installedPackages.size());
				int count=0;
				for (PackageInfo packageInfo : installedPackages) {
					SystemClock.sleep(100);
					//设置进度条最大进度和当前进度
					count++;
					pb_cachefragment_progressbar.setProgress(count);
					
					//设置扫描显示的应用的名称
					final String name = packageInfo.applicationInfo.loadLabel(pm).toString();
					if (getActivity() != null) {
						getActivity().runOnUiThread(new Runnable() {
							
							@Override
							public void run() {
								tv_cachefragment_text.setText("正在扫描:"+name);
							}
						});	
					}
				}
				if (getActivity() != null) {
					getActivity().runOnUiThread(new Runnable() {
						
						@Override
						public void run() {
							tv_cachefragment_text.setVisibility(View.GONE);
							pb_cachefragment_progressbar.setVisibility(View.GONE);
						}
					});
				}
			};
		}.start();
	}

#获取缓存#  (重点:反射+源码查看)

	1.反射操作
					//反射获取缓存
					try {
						Class<?> loadClass = getActivity().getClass().getClassLoader().loadClass("android.content.pm.PackageManager");
						Method method = loadClass.getDeclaredMethod("getPackageSizeInfo", String.class,IPackageStatsObserver.class);
						//receiver : 类的实例,隐藏参数,方法不是静态的必须指定
						method.invoke(pm, packageInfo.packageName,mStatsObserver);
					} catch (Exception e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
	2.远程服务aidl
		//获取缓存大小
		IPackageStatsObserver.Stub mStatsObserver = new IPackageStatsObserver.Stub() {
	        public void onGetStatsCompleted(PackageStats stats, boolean succeeded) {
	        	long cachesize = stats.cacheSize;//缓存大小
	        	long codesize = stats.codeSize;//应用程序的大小
	        	long datasize = stats.dataSize;//数据大小
	        	
	        	String cache = Formatter.formatFileSize(getActivity(), cachesize);
	        	String code = Formatter.formatFileSize(getActivity(), codesize);
	        	String data = Formatter.formatFileSize(getActivity(), datasize);
	        	
	        	System.out.println(stats.packageName+"cachesize:"+cache +" codesize:"+code+" datasize:"+data);
	        }
		};
	3.权限
		<uses-permission android:name="android.permission.GET_PACKAGE_SIZE" />

#展示缓存应用#

	1.使用listview进行展示
		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			
			View cachView;
			ViewHolder viewHolder;
			if (convertView == null) {
				 cachView = View.inflate(getActivity(), R.layout.item_cache, null);
				 viewHolder = new ViewHolder();
				 viewHolder.iv_itemcache_icon = (ImageView) cachView.findViewById(R.id.iv_itemcache_icon);
				 viewHolder.tv_itemcache_name = (TextView) cachView.findViewById(R.id.tv_itemcache_name);
				 viewHolder.tv_itemcache_size = (TextView) cachView.findViewById(R.id.tv_itemcache_size);
				 cachView.setTag(viewHolder);
			}else{
				cachView = convertView;
				viewHolder = (ViewHolder) cachView.getTag();
			}
			//设置显示数据
			CachInfo cachInfo = list.get(position);
			//根据包名获取application信息
			try {
				ApplicationInfo applicationInfo = pm.getApplicationInfo(cachInfo.getPackageName(), 0);
				Drawable icon = applicationInfo.loadIcon(pm);
				String name = applicationInfo.loadLabel(pm).toString();
				//设置显示
				 viewHolder.iv_itemcache_icon.setImageDrawable(icon);
				 viewHolder.tv_itemcache_name.setText(name);
				 viewHolder.tv_itemcache_size.setText(cachInfo.getCachesize());
			} catch (NameNotFoundException e) {
				e.printStackTrace();
			}
			return cachView;
		}

#清理缓存#

	android中当前程序是不能清理其他程序缓存

	1.进入详情界面进行清理
		lv_cachefragment_caches.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> parent, View view,
					int position, long id) {
				//跳转到详情页面
				Intent intent = new Intent();
				intent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS");
				intent.setData(Uri.parse("package:"+list.get(position).getPackageName()));
				startActivity(intent);
			}
		});
	2.通过反射清理所有应用程序的缓存
		//清理缓存
		btn_cachefragment_clear.setOnClickListener(new OnClickListener() {
									
			@Override
			public void onClick(View v) {
											
					//真正的实现清理缓存
					try {
						Class<?> loadClass = getActivity().getClass().getClassLoader().loadClass("android.content.pm.PackageManager");
						//Long.class  Long     TYPE  long
						Method method = loadClass.getDeclaredMethod("freeStorageAndNotify", Long.TYPE,IPackageDataObserver.class);
						method.invoke(pm, Long.MAX_VALUE,new MyIPackageDataObserver());
					} catch (Exception e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					//清理缓存
					list.clear();
					//更新界面
					myadapter.notifyDataSetChanged();
					//隐藏button按钮
					btn_cachefragment_clear.setVisibility(View.GONE);
				}
		});

#异常捕获#  (重点)

	//异常捕获
	//Application : 当前的应用程序,所有的应用最先的执行都是applicaiton
	public class MyApplication extends Application {

		@Override
		public void onCreate() {
			super.onCreate();
			System.out.println("applcation启动了......");
			Thread.currentThread().setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
		}
		private class MyUncaughtExceptionHandler implements UncaughtExceptionHandler{
			//系统中由未捕获的异常的时候调用
			//Throwable : Error和Exception的父类
			@Override
			public void uncaughtException(Thread thread, Throwable ex) {
				System.out.println("哥捕获异常了......");
				ex.printStackTrace();
				try {
					//将捕获到异常,保存到SD卡中
					ex.printStackTrace(new PrintStream(new File("/mnt/sdcard/log.txt")));
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				}
				//myPid() : 获取当前应用程序的进程id
				//自己把自己杀死
				android.os.Process.killProcess(android.os.Process.myPid());
			}
		}
	}

	需要将清单文件中的application改为我们自定义的application
		<application
        	android:name=".MyApplication"

#代码混淆# (重点)

	1.将sdk\tools\proguard\proguard-android.txt拷贝到工程的根目录下
	2.在工程的project.properties文件中将proguard.config=proguard-android.txt:proguard-project.txt代码放开

#广告#

	1.app特别火,广告厂商找你
	2.广告平台   sdk   广告厂商 -> 广告平台 -> 开发者
		1000条  1毛   
		300000下载量    60000活跃量  玩半个小时,1分钟3-5条广告
		60000*30*3 * 30/1000/10
	
	开发必用
	id:4de79868e98eae74
	秘钥:26bf4111c161c2fc

