##手机卫士75期笔记##



##Day12##

#加锁解锁#

	1.在item的布局文件中增加imageview
	2.在getview中判断是否加锁
			//判断应用程序是加锁还是解锁
			if (watchDogDao.queryLockApp(appInfo.getPackagName())) {
				//加锁
				viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.lock);
			}else{
				//解锁
				viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.unlock);
			}
	3.使用长按点击事件实现加锁解锁
		/**
		 * 长按点击事件
		 */
		private void listviewItemLongClick() {
			lv_softmanager_application.setOnItemLongClickListener(new OnItemLongClickListener() {
	
				@Override
				public boolean onItemLongClick(AdapterView<?> parent, View view,
						int position, long id) {
					System.out.println("长按点击事件");
					//true if the callback consumed the long click, false otherwise
					//true:表示执行  false:拦截
					//加锁解锁的操作
					//屏蔽用户和系统程序(..个)不能加锁解锁操作
					if (position == 0 || position == userappinfo.size()+1) {
						return true;
					}
					//获取数据
					if (position <= userappinfo.size()) {
						//用户程序
						appInfo = userappinfo.get(position-1);
					}else{
						//系统程序
						appInfo = systemappinfo.get(position - userappinfo.size() - 2);
					}
					//加锁解锁
					ViewHolder viewHolder = (ViewHolder) view.getTag();
					//判断应用有没有加锁,有的解锁,没有的加锁
					if (watchDogDao.queryLockApp(appInfo.getPackagName())) {
						//解锁操作
						watchDogDao.deleteLockApp(appInfo.getPackagName());
						viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.unlock);
					}else{
						//加锁操作
						watchDogDao.addLockApp(appInfo.getPackagName());
						viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.lock);
					}
					//myadapter.notifyDataSetChanged();
					return true;
				}
			});
		}

#监听用户打开程序#

	1.创创建解锁界面
	2.在服务中,监听用户打开程序的操作中,通过查询数据库的方式判断打开的应用程序是否加锁
				//通过查询数据库,如果数据库中有,弹出解锁界面,没有不作处理
						if (watchDogDao.queryLockApp(packageName)) {
							//弹出解锁界面
							Intent intent = new Intent(WatchDogService.this,WatchDogActivity.class);
							intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
							startActivity(intent);
						}
	3.在解锁界面点击返回键,重复弹出解锁界面
		@Override
		public boolean onKeyDown(int keyCode, KeyEvent event) {
			if (keyCode == KeyEvent.KEYCODE_BACK) {
				/**
				 * Starting: Intent { 
				   act=android.intent.action.MAIN 
				   cat=[android.intent.category.HOME
				   ] cmp=com.android.launcher/com.android.launcher2.Launcher } from pid 208
				 */
				//跳转到主界面
				Intent intent = new Intent();
				intent.setAction("android.intent.action.MAIN");
				intent.addCategory("android.intent.category.HOME");
				startActivity(intent);
				finish();
			}
			return super.onKeyDown(keyCode, event);
		}
	4.不能给当前应用程序加锁
				//判断如果是当前应用程序,就不要加锁
					if (!appInfo.getPackagName().equals(getPackageName())) {
						watchDogDao.addLockApp(appInfo.getPackagName());
						viewHolder.iv_itemsoftmanager_islock.setImageResource(R.drawable.lock);
					}else{
						Toast.makeText(getApplicationContext(), "当前的应用程序不能加锁", 0).show();
					}

#解锁界面优化#

	1.在服务跳转activity的操作中将加锁应用程序的包名传递给解锁界面
			Intent intent = new Intent(WatchDogService.this,WatchDogActivity.class);
			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
			intent.putExtra("packageName", packageName);
			startActivity(intent);
	2.在解锁界面获取传递的数据,并通过包名获取图片和名称
		//接受获取数据
		Intent intent = getIntent();
		packagename = intent.getStringExtra("packageName");
		//设置显示加锁的应用程序的图片和名称
		PackageManager pm = getPackageManager();
		try {
			ApplicationInfo applicationInfo = pm.getApplicationInfo(packagename, 0);
			Drawable icon = applicationInfo.loadIcon(pm);
			String name = applicationInfo.loadLabel(pm).toString();
			//设置显示
			iv_watchdog_icon.setImageDrawable(icon);
			tv_watchdog_name.setText(name);
		} catch (NameNotFoundException e) {
			e.printStackTrace();
		}
	3.解决,点击home最小,打开其他加锁程序,显示上一个加锁程序的图片和名称的bug
		@Override
		protected void onStop() {
			super.onStop();
			finish();
		}

#解锁操作#  (重点:发送广播)

	1.通过发送广播的方式,去给服务发送解锁信息
		if ("123".equals(password)) {
			//解锁
			//一般通过广播的形式将信息发送给服务
			Intent intent = new Intent();
			intent.setAction("com.itheima.mobliesafe75.unlock");//自定义发送广播事件
			intent.putExtra("packagename", packagename);
			sendBroadcast(intent);
			finish();
		}else{
			Toast.makeText(getApplicationContext(), "密码错误", 0).show();
		}
	2.在服务中,通过注册广播的形式实现接受信息并进行解锁操作
		注册广播接受者
			//注册解锁的广播接受者
			//1.广播接受者
			unlockCurrentReceiver = new UnlockCurrentReceiver();
			//2.设置接受的广播事件
			IntentFilter intentFilter = new IntentFilter();
			intentFilter.addAction("com.itheima.mobliesafe75.unlock");
		接受信息
			private class UnlockCurrentReceiver extends BroadcastReceiver{
	
				@Override
				public void onReceive(Context context, Intent intent) {
					//解锁操作
					unlockcurrentPackagname = intent.getStringExtra("packagename");
				}
			}
		解锁操作
			//通过查询数据库,如果数据库中有,弹出解锁界面,没有不作处理
			if (watchDogDao.queryLockApp(packageName)) {
				if (!packageName.equals(unlockcurrentPackagname)) {
					//弹出解锁界面
					Intent intent = new Intent(WatchDogService.this,WatchDogActivity.class);
					intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
					intent.putExtra("packageName", packageName);
					startActivity(intent);
				}
			}
		
	3.加锁操作,锁屏之后重新加锁
		a.注册锁屏的广播接受者
			//注册锁屏的广播接受者
			screenOffReceiver = new ScreenOffReceiver();
			IntentFilter screenOffIntentFilter = new IntentFilter();
			screenOffIntentFilter.addAction(Intent.ACTION_SCREEN_OFF);
			registerReceiver(screenOffReceiver, screenOffIntentFilter);
		b.在锁屏的广播接受者中将包名表示设置为null,表示加锁操作
			private class  ScreenOffReceiver extends BroadcastReceiver{

				@Override
				public void onReceive(Context context, Intent intent) {
					//加锁的操作
					unlockcurrentPackagname = null;
				}
			}

#两个bug解决方案#  (重点:启动模式)

	1.启动模式
		<activity android:name=".WatchDogActivity"
            android:launchMode="singleInstance"
            ></activity>
        <!-- 
        	standard : 标准的启动模式
        	singleTop : 如果activity在栈顶,直接使用
        	singleTask : 如果任务栈中有activity的,之前的activity删除,将activity置顶
        	singleInstance : 将activity单独存放一个任务栈中
         -->
	2.从最近列表中删除手机卫士应用
		android:excludeFromRecents="true"
		excludeFromRecents : 是否在最近列表中显示    true:不显示      false:显示,只有设置这个属性的activity运行了,这个属性才会生效

#数据库优化#  (重点:内容观察者)

	1.当数据库发生变化,通知内容观察者进行更新数据,在数据库操作中,比如添加,删除
			//通知内容观察者数据库变化了
			ContentResolver contentResolver = context.getContentResolver();
			//因为是我们自己的数据发生变化了,所以我们要自定义一个uri进行操作
			Uri uri = Uri.parse("content://com.itheima.mobliesafe75.lock.changed");
			//通知内容观察者数据发生变化了
			contentResolver.notifyChange(uri, null);
	2.使用内容观察者进行数据更新操作
				//先将数据库中的数据,查询存放到内存,然后再把数据从内存中获取出来进行操作
				
				//当数据库变化的时候重新更新内存中的数据,当数据库变化的时候通知内容观察者数据库变化了,然后在内容观察者中去更新最新的数据
				Uri uri = Uri.parse("content://com.itheima.mobliesafe75.lock.changed");
				//notifyForDescendents:匹配规则,true:精确匹配  false:模糊匹配
				getContentResolver().registerContentObserver(uri, true, new ContentObserver(null) {
					public void onChange(boolean selfChange) {
						//更新数据
						list = watchDogDao.querAllLockApp();
					};
				});
	3.使用内存中的数据,使用list集合中的数据
						//判断list集合中是否包含包名
						boolean b = list.contains(packageName);
						//通过查询数据库,如果数据库中有,弹出解锁界面,没有不作处理
						if (b) {
							if (!packageName.equals(unlockcurrentPackagname)) {
								//弹出解锁界面
								Intent intent = new Intent(WatchDogService.this,WatchDogActivity.class);
								intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
								intent.putExtra("packageName", packageName);
								startActivity(intent);
							}
						}

#获取短信#

	/**
	 * 获取短信
	 */
	public static void getAllSMS(Context context){
		//1.获取内容解析者
		ContentResolver resolver = context.getContentResolver();
		//2.获取内容提供者地址   sms,sms表的地址:null  不写
		//3.获取查询路径
		Uri uri = Uri.parse("content://sms");
		//4.查询操作
		//projection : 查询的字段
		//selection : 查询的条件
		//selectionArgs : 查询条件的参数
		//sortOrder : 排序
		Cursor cursor = resolver.query(uri, new String[]{"address","date","type","body"}, null, null, null);
		//5.解析cursor
		while(cursor.moveToNext()){
			String address = cursor.getString(0);
			String date = cursor.getString(1);
			String type = cursor.getString(2);
			String body = cursor.getString(3);
			System.out.println("address:"+address+"   date:"+date+"  type:"+type+"  body:"+body);
		}
	}

	权限
	 <uses-permission android:name="android.permission.READ_SMS"/>
     <uses-permission android:name="android.permission.WRITE_SMS"/>

#备份短信#  (重点:创建xml文件)

	1.数据库
	2.文件   xml

	/**
	 * 获取短信
	 */
	public static void getAllSMS(Context context){
		//1.获取短信
		//1.1获取内容解析者
		ContentResolver resolver = context.getContentResolver();
		//1.2获取内容提供者地址   sms,sms表的地址:null  不写
		//1.3获取查询路径
		Uri uri = Uri.parse("content://sms");
		//1.4.查询操作
		//projection : 查询的字段
		//selection : 查询的条件
		//selectionArgs : 查询条件的参数
		//sortOrder : 排序
		Cursor cursor = resolver.query(uri, new String[]{"address","date","type","body"}, null, null, null);
		
		
		//2.备份短信
		//2.1获取xml序列器
		XmlSerializer xmlSerializer = Xml.newSerializer();
		try {
			//2.2设置xml文件保存的路径
			//os : 保存的位置
			//encoding : 编码格式
			xmlSerializer.setOutput(new FileOutputStream(new File("/mnt/sdcard/backupsms.xml")), "utf-8");
			//2.3设置头信息
			//standalone : 是否独立保存
			xmlSerializer.startDocument("utf-8", true);
			//2.4设置根标签
			xmlSerializer.startTag(null, "smss");
			//1.5.解析cursor
			while(cursor.moveToNext()){
				//2.5设置短信的标签
				xmlSerializer.startTag(null, "sms");
				//2.6设置文本内容的标签
				xmlSerializer.startTag(null, "address");
				String address = cursor.getString(0);
				//2.7设置文本内容
				xmlSerializer.text(address);
				xmlSerializer.endTag(null, "address");
				
				xmlSerializer.startTag(null, "date");
				String date = cursor.getString(1);
				xmlSerializer.text(date);
				xmlSerializer.endTag(null, "date");
				
				xmlSerializer.startTag(null, "type");
				String type = cursor.getString(2);
				xmlSerializer.text(type);
				xmlSerializer.endTag(null, "type");
				
				xmlSerializer.startTag(null, "body");
				String body = cursor.getString(3);
				xmlSerializer.text(body);
				xmlSerializer.endTag(null, "body");
				
				xmlSerializer.endTag(null, "sms");
				System.out.println("address:"+address+"   date:"+date+"  type:"+type+"  body:"+body);
				
			}
			xmlSerializer.endTag(null, "smss");
			xmlSerializer.endDocument();
			//2.8将数据刷新到文件中
			xmlSerializer.flush();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
	}

#备份效果#  (重点:progressdialog+回调函数)

	1.progerssdialog
		//progressdialog是可以在子线程中更新
		progressDialog = new ProgressDialog(this);
		progressDialog.setCancelable(false);//不能取消
		progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
		/*progressDialog.setMax(max);//设置最大进度
		progressDialog.setProgress(value);//设置当前进度
		*/progressDialog.show();
	2.使用progerssbar
		progerssbar.setMax(max);//设置最大进度
		progerssbar.setProgress(value)

	回调函数
		1.创建刷子
			public interface ShowProgress{
				//设置最大进度
				public void setMax(int max);
				//设置当前进度
				public void setProgress(int progerss);
			}
		2.媳妇儿给你刷子
			public static void getAllSMS(Context context,ShowProgress showProgress){
		
				//设置最大进度
				int count = cursor.getCount();//获取短信的个数
				showProgress.setMax(count);


				//设置当前进度
				progress++;
				showProgress.setProgress(progress);
			}
		3.我们接受刷子,进行刷牙,刷鞋,刷马桶.....
				SMSEngine.getAllSMS(getApplicationContext(),new ShowProgress() {
					
					@Override
					public void setProgress(int progerss) {
						//progressDialog.setProgress(progerss);
						pb_atools_sms.setProgress(progerss);
					}
					
					@Override
					public void setMax(int max) {
						//progressDialog.setMax(max);
						pb_atools_sms.setMax(max);
					}
				});	


#短信还原#

	/**
	 * 短信还原
	 * @param v
	 */
	public void restoresms(View v){
		//解析xml
		//XmlPullParser xmlPullParser = Xml.newPullParser();
		//插入短信
		ContentResolver resolver = getContentResolver();
		Uri uri = Uri.parse("content://sms");
		ContentValues values = new ContentValues();
		values.put("address", "95588");
		values.put("date", System.currentTimeMillis());
		values.put("type", 1);
		values.put("body", "zhuan zhang le $10000000000000000000");
		resolver.insert(uri, values);
	}

#可扩展的listview#

	1.布局文件中
		<ExpandableListView 
	    android:id="@+id/exlitview"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    ></ExpandableListView>
	2.使用
		exlitview = (ExpandableListView) findViewById(R.id.exlitview);
		exlitview.setAdapter(new MyAdapter());

		private class MyAdapter extends BaseExpandableListAdapter{
				//获取组的个数
				@Override
				public int getGroupCount() {
					// TODO Auto-generated method stub
					return 8;
				}
				//获取每组孩子的个数
				@Override
				public int getChildrenCount(int groupPosition) {
					// TODO Auto-generated method stub
					return groupPosition+1;
				}
				//设置组对应的相应的信息
				@Override
				public Object getGroup(int groupPosition) {
					// TODO Auto-generated method stub
					return null;
				}
				//设置每组孩子对应的信息
				//groupPosition ：组的位置
				//childPosition : 孩子的位置
				@Override
				public Object getChild(int groupPosition, int childPosition) {
					// TODO Auto-generated method stub
					return null;
				}
				//获取组的id
				@Override
				public long getGroupId(int groupPosition) {
					// TODO Auto-generated method stub
					return 0;
				}
				//获取每组孩子的id
				@Override
				public long getChildId(int groupPosition, int childPosition) {
					// TODO Auto-generated method stub
					return 0;
				}
				//获取id是否稳定,有没有设置id,有设置,返回true,没有设置返回false
				@Override
				public boolean hasStableIds() {
					// TODO Auto-generated method stub
					return false;
				}
				//设置组的样式
				@Override
				public View getGroupView(int groupPosition, boolean isExpanded,
						View convertView, ViewGroup parent) {
					TextView textView = new TextView(getApplicationContext());
					textView.setText("         我是第"+groupPosition+"组");
					textView.setTextColor(Color.RED);
					return textView;
				}
				//设置每组孩子样式
				@Override
				public View getChildView(int groupPosition, int childPosition,
						boolean isLastChild, View convertView, ViewGroup parent) {
					
					TextView textView = new TextView(getApplicationContext());
					textView.setText("我是第"+groupPosition+"组的第"+childPosition+"个孩子");
					textView.setTextColor(Color.GREEN);
					return textView;
				}
				//设置孩子是否能够被点击,true:可以   false:不可以
				@Override
				public boolean isChildSelectable(int groupPosition, int childPosition) {
					// TODO Auto-generated method stub
					return false;
				}
				
			}

#抽屉效果#  (重点)

	slidingmenu  第三方法框架

	1.SlidingDrawer
		<SlidingDrawer 
	        android:layout_width="match_parent"
	        android:layout_height="match_parent"
	        android:handle="@+id/handle"
	        android:content="@+id/content"
	        android:orientation="vertical"
	        >
	        <LinearLayout 
	             android:id="@+id/handle"
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            >
	            <ImageView 
	            android:layout_width="wrap_content"
	            android:layout_height="wrap_content"
	            android:src="@drawable/shenmabg"
	            />
	        </LinearLayout>
	        <LinearLayout 
	            android:id="@+id/content"
	            android:layout_width="match_parent"
	            android:layout_height="match_parent"
	            android:background="#ff0000"
	            ></LinearLayout>
	    </SlidingDrawer>
		
	2.android.support.v4.widget.DrawerLayout
		<android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent"
		    android:orientation="vertical" 
		    android:id="@+id/dl"
		    >
		
		   <RelativeLayout 
		       android:layout_width="match_parent"
		       android:layout_height="match_parent"
		       >
		    <TextView
		        android:id="@+id/textView1"
		        android:layout_width="match_parent"
		        android:layout_height="wrap_content"
		        android:text="流量统计" 
		        android:background="#8866ff00"
		        android:gravity="center_horizontal"
		        android:textSize="22sp"
		        android:paddingTop="5dp"
		        android:paddingBottom="5dp"
		        />
		    </RelativeLayout>
		    <!-- layout_gravity : 在布局中决定控件存在位置 -->
		    <LinearLayout 
		        android:layout_width="match_parent"
		        android:layout_height="match_parent"
		        android:layout_gravity="right"
		        android:background="#ff0000"
		        ></LinearLayout>
		    <LinearLayout 
		        android:layout_width="match_parent"
		        android:layout_height="match_parent"
		        android:layout_gravity="left"
		        android:background="#0000ff"
		        ></LinearLayout>
        
	

	代码中使用
		DrawerLayout dl = (DrawerLayout) findViewById(R.id.dl);
//		dl.openDrawer(Gravity.RIGHT);//表示默认打开哪个方向布局
		dl.openDrawer(Gravity.LEFT);

##Day13##

#病毒#

	病毒 : 一段带有恶意行为的计算机程序
	恶搞 : 炫耀技术,熊猫烧香,损人不利己
	灰鸽子 : 盗号,qq,游戏账号
	肉机 : 通过一段程序控制的电脑
	
	杀毒软件历史
		1.黑名单  : 将已有的病毒保存到数据库中,卡巴斯基,江民,瑞星,金山,问题:不能及时发现病毒,蜜罐,云查杀
		2.白名单  : 360  把查杀过的应用发送数据库中

	手机端:黑名单

#手机杀毒界面#

	layer-list : 图层,帧布局framlayout,可以将图片一层叠一层展示,布局文件中最下面的控件,显示的时候在最上面

	1.布局
			<RelativeLayout 
	        android:layout_width="match_parent"
	        android:layout_height="wrap_content"
	        >
	        <ImageView 
	            android:id="@+id/iv_antivirus_anitimageview"
	            android:layout_width="80dp"
	            android:layout_height="80dp"
	            android:src="@drawable/ic_scanner_malware"
	            android:layout_margin="10dp"
	            />
	        <ImageView 
	            android:id="@+id/iv_antivirus_scanner"
	            android:layout_width="80dp"
	            android:layout_height="80dp"
	            android:src="@drawable/act_scanning_03"
	            android:layout_margin="10dp"
	            />
	        <TextView 
	            android:id="@+id/tv_antivirus_text"
	            android:layout_width="match_parent"
	            android:layout_height="wrap_content"
	            android:text="正在扫描..."
	            android:layout_toRightOf="@id/iv_antivirus_anitimageview"
	            android:layout_marginTop="25dp"
	            android:textSize="18sp"
	            android:layout_marginRight="15dp"
	            />
			<!-- progress : 设置进度条当前进度 -->
	        <ProgressBar
	            android:id="@+id/pb_antivirus_progressbar"
	            style="?android:attr/progressBarStyleHorizontal"
	            android:layout_width="match_parent"
	            android:layout_height="wrap_content"
	            android:layout_below="@id/tv_antivirus_text"
	            android:layout_toRightOf="@id/iv_antivirus_anitimageview"
	            android:layout_marginTop="5dp"
	            android:layout_marginRight="15dp"
	            android:progressDrawable="@drawable/progerssbar_antivirus_bg"
	            android:progress="30"
	            />
	
	    </RelativeLayout>
	2.图层  res->drawable -> xxx.xml
		<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
		    <item android:id="@android:id/background">
		      <bitmap android:src="@drawable/security_progress_bg"
		        android:gravity="center" />
		    </item>
		    <item android:id="@android:id/secondaryProgress">
		      <bitmap android:src="@drawable/security_progress"
		        android:gravity="center" />
		    </item>
		    <item android:id="@android:id/progress">
		      <bitmap android:src="@drawable/security_progress"
		        android:gravity="center" />
		    </item>
		</layer-list>
	3.更改样式,progressbar的属性
		android:progressDrawable="@drawable/progerssbar_antivirus_bg"


#扫描操作#  (重点:动画)


		//设置旋转动画
		//fromDegrees : 旋转开始的角度
		//toDegrees : 结束的角度
		//后面四个:是以自身变化还是以父控件变化
		//Animation.RELATIVE_TO_SELF : 以自身旋转
		//Animation.RELATIVE_TO_PARENT : 以父控件旋转
		RotateAnimation rotateAnimation = new RotateAnimation(0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
		rotateAnimation.setDuration(1000);//持续时间
		rotateAnimation.setRepeatCount(Animation.INFINITE);//设置旋转的次数,INFINITE:一直旋转
		
		//设置动画插补器
		LinearInterpolator linearInterpolator = new LinearInterpolator();
		rotateAnimation.setInterpolator(linearInterpolator);
		iv_antivirus_scanner.startAnimation(rotateAnimation);

	展示软件列表  1.listview   2.linearlayout添加textview
		
    /**
	 * 扫描程序
	 */
	private void scanner() {
		//1.获取包的管理者
		final PackageManager pm = getPackageManager();
		tv_antivirus_text.setText("正在初始化64核杀毒引擎....");
		new Thread(){
			public void run() {
				//延迟一秒中扫描程序
				SystemClock.sleep(100);
				//2.获取所有安装应用程序信息
				List<PackageInfo> installedPackages = pm.getInstalledPackages(0);
				
				//3.1设置进度条最大进度
				pb_antivirus_progressbar.setMax(installedPackages.size());
				//3.2设置当前进度
				int count=0;
				for (PackageInfo packageInfo : installedPackages) {
					SystemClock.sleep(100);
					//3.设置进度条的最大进度和当前进度
					count++;
					pb_antivirus_progressbar.setProgress(count);
					
					//4.设置扫描显示软件名称
					final String name = packageInfo.applicationInfo.loadLabel(pm).toString();
					//在ui线程(主线程)进行操作
					runOnUiThread(new Runnable() {//封装了handler
						
						@Override
						public void run() {
							tv_antivirus_text.setText("正在扫描:"+name);
							
							//6.展示扫描软件的名称信息
							TextView textView = new TextView(getApplicationContext());
							textView.setTextColor(Color.BLACK);
							textView.setText(name);
							//textview添加到线性布局中
							//ll_antivirus_safeapks.addView(textView);
							ll_antivirus_safeapks.addView(textView, 0);//index:将textview添加到线性布局的哪个位置
						}
					});
				};
				//5.扫描完成,显示扫描完成信息,同时旋转动画停止
				runOnUiThread(new Runnable() {
					
					@Override
					public void run() {
						//设置显示信息以及停止动画
						tv_antivirus_text.setText("扫描完成,未发现病毒");
						iv_antivirus_scanner.clearAnimation();//移出动画
					}
				});
			};
		}.start();
	}

#获取签名信息# (重点:指定信息的标签)

	1.指定获取签名信息标签
		List<PackageInfo> installedPackages = pm.getInstalledPackages(PackageManager.GET_SIGNATURES);
	2.获取签名信息
		//7.获取应用程序的签名,并进行md5加密
		Signature[] signatures= packageInfo.signatures;//获取应用程序的签名信息,获取签名的数组
		String charsString = signatures[0].toCharsString();
		//对签名信息进行MD5加密
		String signature = MD5Util.passwordMD5(charsString);
		System.out.println(name+"  : "+signature);

#手机杀毒#

	1.将病毒库导入到手机中,参考splashactivity中拷贝数据库操作,增加方法传递参数
	2.创建查询数据库操作
			//查询Md5值是否在数据库中
			public class AntiVirusDao {
				/**
				 * 查询Md5值是否在病毒数据库中
				 * @param context
				 * @param md5
				 * @return
				 */
				public static boolean queryAntiVirus(Context context,String md5){
					boolean ishave = false;
					//1.获取数据库的路径
					File file = new File(context.getFilesDir(), "antivirus.db");
					SQLiteDatabase database = SQLiteDatabase.openDatabase(file.getAbsolutePath(), null, SQLiteDatabase.OPEN_READONLY);
					Cursor cursor = database.query("datable", null, "md5=?", new String[]{md5}, null, null, null);
					if (cursor.moveToNext()) {
						ishave = true;
					}
					cursor.close();
					database.close();
					return ishave;
				}
			}
	3.使用
		//8.查询MD5值是否在病毒数据库中
		boolean b = AntiVirusDao.queryAntiVirus(getApplicationContext(), signature);
	4.根据查询值,设置病毒标示
		//6.展示扫描软件的名称信息
		TextView textView = new TextView(getApplicationContext());
		//9.根据返回的值将病毒标示出来
		if (b) {
			//有病毒
			textView.setTextColor(Color.RED);
			//将病毒的包名添加到list集合
			list.add(packageInfo.packageName);
		}else{
			//没有病毒
			textView.setTextColor(Color.BLACK);
		}
		textView.setText(name);
	5.对查询到病毒进行处理
						//10.根据是否有病毒进行显示操作
						if (list.size() > 0) {
							//有病毒
							tv_antivirus_text.setText("扫描完成,发现"+list.size()+"个病毒");
							//卸载病毒应用
							AlertDialog.Builder builder = new Builder(AntivirusActivity.this);
							builder.setTitle("提醒!发现"+list.size()+"个病毒");
							builder.setIcon(R.drawable.ic_launcher);
							builder.setMessage("是否卸载病毒应用!");
							builder.setPositiveButton("卸载", new DialogInterface.OnClickListener() {
								
								@Override
								public void onClick(DialogInterface dialog, int which) {
									//卸载操作
									for (String packagname : list) {
										Intent intent = new Intent();
										intent.setAction("android.intent.action.DELETE");
										intent.addCategory("android.intent.category.DEFAULT");
										intent.setData(Uri.parse("package:"+packagname));
										startActivity(intent);
									}
									dialog.dismiss();
								}
							});
							builder.setNegativeButton("取消", null);
							builder.show();
						}else{
							//设置显示信息以及停止动画
							tv_antivirus_text.setText("扫描完成,未发现病毒");
						}

#缓存清理框架# (重点!!!!!!)

	1.将activity改为继承fragmentActivity
		//如果要对fragment进行管理操作,activity必须继承fragmentActivity
		public class ClearCacheActivity extends FragmentActivity {
		}
	2.设置布局文件
		!-- fragment替换的控件 -->
	    <FrameLayout 
	        android:id="@+id/fram_clearcache_fragment"
	        android:layout_width="match_parent"
	        android:layout_height="match_parent"
	        android:layout_weight="1"
	        ></FrameLayout>
	   <LinearLayout 
	       android:layout_width="match_parent"
	       android:layout_height="wrap_content"
	       >
	    
	    <Button 
	        android:layout_width="0dp"
	        android:layout_weight="1"
	        android:layout_height="wrap_content"
	        android:text="缓存清理"
	        android:background="@drawable/selector_contact_button"
	        android:onClick="cache"
	        />
	    
	    <Button 
	        android:layout_width="0dp"
	        android:layout_weight="1"
	        android:layout_height="wrap_content"
	        android:text="SD卡清理"
	         android:background="@drawable/selector_contact_button"
	         android:onClick="sd"
	        />
	    </LinearLayout>
	3.创建fragment
		public class CacheFragment extends Fragment {
			//初始化操作
			@Override
			public void onCreate(Bundle savedInstanceState) {
				// TODO Auto-generated method stub
				super.onCreate(savedInstanceState);
			}
			//设置fragment的布局
			@Override
			public View onCreateView(LayoutInflater inflater, ViewGroup container,
					Bundle savedInstanceState) {
				//参数1:布局文件
				//参数2:容器
				//参数3:自动挂载  ,一律false
				View view= inflater.inflate(R.layout.fragment_cache, container, false);
				return view;
			}
			//设置填充显示数据
			@Override
			public void onActivityCreated(Bundle savedInstanceState) {
				// TODO Auto-generated method stub
				super.onActivityCreated(savedInstanceState);
			}
			
		}
	4.创建fragment布局文件,线性布局,背景是红色
	5.在actiivty中添加fragment
		@Override
		protected void onCreate(Bundle savedInstanceState) {
			super.onCreate(savedInstanceState);
			setContentView(R.layout.activity_clearcache);
			
			//挂载fragment
			//1.获取fragment
			cacheFragment = new CacheFragment();
			sdFragment = new SDFragment();
			//2.加载fragment
			//2.1获取fragment的管理者
			supportFragmentManager = getSupportFragmentManager();
			//2.2开启事务
			FragmentTransaction beginTransaction = supportFragmentManager.beginTransaction();
			//2.3添加fragment操作
			//数据不会重新刷新
			//参数1:fragment要替换的控件的id
			//参数2:要替换fragment
			beginTransaction.add(R.id.fram_clearcache_fragment, cacheFragment);
			//界面展示以最后一个添加的为准
			beginTransaction.add(R.id.fram_clearcache_fragment, sdFragment);
			//隐藏fragment操作
			beginTransaction.hide(sdFragment);
			//也可以实现替换操作,数据会重新刷新
			//beginTransaction.replace(arg0, arg1)
			//2.4提交事务
			beginTransaction.commit();
		}
	6.隐藏显示fragment操作
		//缓存清理
		public void cache(View v){
			//隐藏sdfragment,显示cacheFragment
			//1.获取事务
			FragmentTransaction beginTransaction = supportFragmentManager.beginTransaction();
			//2.隐藏显示操作
			beginTransaction.hide(sdFragment);//隐藏fragmnt
			beginTransaction.show(cacheFragment);//显示fragment操作
			//3.提交
			beginTransaction.commit();
		}

#缓存清理扫描操作#

	/**
	 * 扫描
	 */
	private void scanner() {
		//1.获取包的管理者
		//getActivity() : 获取fragment所在的activity
		final PackageManager pm = getActivity().getPackageManager();
		tv_cachefragment_text.setText("正在初始化128核扫描引擎.....");
		new Thread(){
			public void run() {
				SystemClock.sleep(100);
				List<PackageInfo> installedPackages = pm.getInstalledPackages(0);
				//设置进度条最大进度
				pb_cachefragment_progressbar.setMax(installedPackages.size());
				int count=0;
				for (PackageInfo packageInfo : installedPackages) {
					SystemClock.sleep(100);
					//设置进度条最大进度和当前进度
					count++;
					pb_cachefragment_progressbar.setProgress(count);
					
					//设置扫描显示的应用的名称
					final String name = packageInfo.applicationInfo.loadLabel(pm).toString();
					if (getActivity() != null) {
						getActivity().runOnUiThread(new Runnable() {
							
							@Override
							public void run() {
								tv_cachefragment_text.setText("正在扫描:"+name);
							}
						});	
					}
				}
				if (getActivity() != null) {
					getActivity().runOnUiThread(new Runnable() {
						
						@Override
						public void run() {
							tv_cachefragment_text.setVisibility(View.GONE);
							pb_cachefragment_progressbar.setVisibility(View.GONE);
						}
					});
				}
			};
		}.start();
	}

#获取缓存#  (重点:反射+源码查看)

	1.反射操作
					//反射获取缓存
					try {
						Class<?> loadClass = getActivity().getClass().getClassLoader().loadClass("android.content.pm.PackageManager");
						Method method = loadClass.getDeclaredMethod("getPackageSizeInfo", String.class,IPackageStatsObserver.class);
						//receiver : 类的实例,隐藏参数,方法不是静态的必须指定
						method.invoke(pm, packageInfo.packageName,mStatsObserver);
					} catch (Exception e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
	2.远程服务aidl
		//获取缓存大小
		IPackageStatsObserver.Stub mStatsObserver = new IPackageStatsObserver.Stub() {
	        public void onGetStatsCompleted(PackageStats stats, boolean succeeded) {
	        	long cachesize = stats.cacheSize;//缓存大小
	        	long codesize = stats.codeSize;//应用程序的大小
	        	long datasize = stats.dataSize;//数据大小
	        	
	        	String cache = Formatter.formatFileSize(getActivity(), cachesize);
	        	String code = Formatter.formatFileSize(getActivity(), codesize);
	        	String data = Formatter.formatFileSize(getActivity(), datasize);
	        	
	        	System.out.println(stats.packageName+"cachesize:"+cache +" codesize:"+code+" datasize:"+data);
	        }
		};
	3.权限
		<uses-permission android:name="android.permission.GET_PACKAGE_SIZE" />

#展示缓存应用#

	1.使用listview进行展示
		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			
			View cachView;
			ViewHolder viewHolder;
			if (convertView == null) {
				 cachView = View.inflate(getActivity(), R.layout.item_cache, null);
				 viewHolder = new ViewHolder();
				 viewHolder.iv_itemcache_icon = (ImageView) cachView.findViewById(R.id.iv_itemcache_icon);
				 viewHolder.tv_itemcache_name = (TextView) cachView.findViewById(R.id.tv_itemcache_name);
				 viewHolder.tv_itemcache_size = (TextView) cachView.findViewById(R.id.tv_itemcache_size);
				 cachView.setTag(viewHolder);
			}else{
				cachView = convertView;
				viewHolder = (ViewHolder) cachView.getTag();
			}
			//设置显示数据
			CachInfo cachInfo = list.get(position);
			//根据包名获取application信息
			try {
				ApplicationInfo applicationInfo = pm.getApplicationInfo(cachInfo.getPackageName(), 0);
				Drawable icon = applicationInfo.loadIcon(pm);
				String name = applicationInfo.loadLabel(pm).toString();
				//设置显示
				 viewHolder.iv_itemcache_icon.setImageDrawable(icon);
				 viewHolder.tv_itemcache_name.setText(name);
				 viewHolder.tv_itemcache_size.setText(cachInfo.getCachesize());
			} catch (NameNotFoundException e) {
				e.printStackTrace();
			}
			return cachView;
		}

#清理缓存#

	android中当前程序是不能清理其他程序缓存

	1.进入详情界面进行清理
		lv_cachefragment_caches.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> parent, View view,
					int position, long id) {
				//跳转到详情页面
				Intent intent = new Intent();
				intent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS");
				intent.setData(Uri.parse("package:"+list.get(position).getPackageName()));
				startActivity(intent);
			}
		});
	2.通过反射清理所有应用程序的缓存
		//清理缓存
		btn_cachefragment_clear.setOnClickListener(new OnClickListener() {
									
			@Override
			public void onClick(View v) {
											
					//真正的实现清理缓存
					try {
						Class<?> loadClass = getActivity().getClass().getClassLoader().loadClass("android.content.pm.PackageManager");
						//Long.class  Long     TYPE  long
						Method method = loadClass.getDeclaredMethod("freeStorageAndNotify", Long.TYPE,IPackageDataObserver.class);
						method.invoke(pm, Long.MAX_VALUE,new MyIPackageDataObserver());
					} catch (Exception e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					//清理缓存
					list.clear();
					//更新界面
					myadapter.notifyDataSetChanged();
					//隐藏button按钮
					btn_cachefragment_clear.setVisibility(View.GONE);
				}
		});

#异常捕获#  (重点)

	//异常捕获
	//Application : 当前的应用程序,所有的应用最先的执行都是applicaiton
	public class MyApplication extends Application {

		@Override
		public void onCreate() {
			super.onCreate();
			System.out.println("applcation启动了......");
			Thread.currentThread().setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
		}
		private class MyUncaughtExceptionHandler implements UncaughtExceptionHandler{
			//系统中由未捕获的异常的时候调用
			//Throwable : Error和Exception的父类
			@Override
			public void uncaughtException(Thread thread, Throwable ex) {
				System.out.println("哥捕获异常了......");
				ex.printStackTrace();
				try {
					//将捕获到异常,保存到SD卡中
					ex.printStackTrace(new PrintStream(new File("/mnt/sdcard/log.txt")));
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				}
				//myPid() : 获取当前应用程序的进程id
				//自己把自己杀死
				android.os.Process.killProcess(android.os.Process.myPid());
			}
		}
	}

	需要将清单文件中的application改为我们自定义的application
		<application
        	android:name=".MyApplication"

#代码混淆# (重点)

	1.将sdk\tools\proguard\proguard-android.txt拷贝到工程的根目录下
	2.在工程的project.properties文件中将proguard.config=proguard-android.txt:proguard-project.txt代码放开

#广告#

	1.app特别火,广告厂商找你
	2.广告平台   sdk   广告厂商 -> 广告平台 -> 开发者
		1000条  1毛   
		300000下载量    60000活跃量  玩半个小时,1分钟3-5条广告
		60000*30*3 * 30/1000/10
	
	开发必用
	id:4de79868e98eae74
	秘钥:26bf4111c161c2fc

